{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Chapter One: Introduction to XIDs</p> <ul> <li>\u00a71.1: Creating Your First XID</li> <li>\u00a71.2: Making a XID Verifiable</li> </ul> <p>Chapter Two: Making Claims (And Protecting Them)</p> <ul> <li>\u00a72.1: Creating Self Attestations</li> <li>\u00a72.2: Managing Sensitive Claims with Elision</li> <li>[\u00a72.3: Managing Sensitive Claims with Encryption] (IN PROCESS)</li> </ul> <p>This course is built from GitHub. You can read there if you prefer.</p>"},{"location":"01_0_Introduction/","title":"Chapter One: Introduction to XIDs","text":"<p>The XID is a powerful new identifier. It's an autonomous cryptographic object that can be used to create truly self-sovereign identity. This first chapter introduces XIDs, shows how to create them, and reveals how to keep them up to date.</p> <p>Like the rest of this course, this chapter uses the story of Amira to create a throughline for the lessons. She is a software developer with a politically sensitive background who wants to contribute to social impact projects without risking her professional position or revealing her identity,</p> <p>This course requires basic terminal/command line familiarity and the ability to download applications through Rust's cargo utility. The initial difficulty is \"Beginner,\" though that may increase across the span of the course.</p>"},{"location":"01_0_Introduction/#major-objectives-for-this-chapter","title":"Major Objectives for this Chapter","text":"<p>After working through this chapter, a developer will be able to:</p> <ul> <li>Create a basic XID for pseudonymous identity.</li> <li>Create public views of a XID using elision.</li> <li>Publish a XID Document.</li> <li>Assess trust levels for pseudonymous identities.</li> </ul> <p>Supporting objectives include the ability to:</p> <ul> <li>Understand what a XID is.</li> <li>Know what a pseudonymous identity is.</li> <li>Understand the power of dereferencing.</li> </ul>"},{"location":"01_0_Introduction/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Section One: Creating Your First XID</li> <li>Section Two: Making a XID Verifiable</li> </ul>"},{"location":"01_1_Your_First_XID/","title":"1.1: Creating Your First XID","text":"<p>This section demonstrates how to create a basic XID (eXtensible IDentifier) that enables pseudonymous contributions while maintaining security. </p> <p>\ud83e\udde0 Related Concepts. Before or after completing this tutorial, you may want to read about XID Fundamentals and Gordian Envelope Basics to understand the theoretical foundations.</p>"},{"location":"01_1_Your_First_XID/#objectives-for-this-section","title":"Objectives for this Section","text":"<p>After working through this section, a developer will be able to:</p> <ul> <li>Create a basic XID for pseudonymous identity</li> <li>Create public views of your XID using elision</li> <li>Maintain strong cryptographic integrity while sharing selectively</li> <li>Verify signature</li> <li>Examine provenance marks</li> </ul> <p>Supporting objectives include the ability to:</p> <ul> <li>Understand what a XID is.</li> <li>Know what a pseudonymous identity is.</li> <li>Understand XID file organization using secure naming conventions</li> </ul>"},{"location":"01_1_Your_First_XID/#amiras-story-why-pseudonymous-identity-matters","title":"Amira's Story: Why Pseudonymous Identity Matters","text":"<p>Amira is a successful software developer working at a prestigious multinational bank in Boston. With her expertise in distributed systems security, she earns a comfortable living, but she wants more purpose in her work. She is considering contributing to social-impact programs, but she can't do so under her real name. That's because Amira's position is somewhat vulnerable. She's a South American programmer working on an H-1B visa, and in modern America that could be revoked for any sort of activism. She also grew up in a politically tense region, and her work on social-impact projects could endanger family members back home. Yet she's deeply motivated to use her skills to help oppressed people globally. This tension between professional security and meaningful contribution creates a specific need.</p> <p>Anonymous submissions could resolve these issues. However, anonymous contributions lack credibility. Project maintainers need confidence in the quality and provenance of code, especially for socially important applications. Amira needs a better solution, one that protects her identity while allowing her to build a verifiable reputation for her skills. This would allow her to build trust through the quality of her work rather than existing credentials and so establish a consistent presence that can evolve over time.</p> <p>On the advice of her friend Charlene, Amira investigates RISK, a network that connects developers with social-impact projects and protects participants' privacy. It uses a Blockchain Commons technology called XIDs: these \"eXtensible IDentifiers\" enable pseudonymous identity with progressive trust development. Amira will use RISK to create the \"BRadvoc8\" (Basic Rights Advocate) identity. Through RISK, Amira can then connect with project leaders such as Ben, who runs a women's services non-profit that Amira wishes to contribute to. This will allow her to safely collaborate on projects aligned with her values while maintaining separation between her pseudonymous contributions and her legal identity, protecting herself from adversaries who might target her or her family for her work.</p> <p>\ud83d\udcd6 What is a Pseudonymous Identity? A pseudoynmous identity is an ongoing identity that's intended for continuous usage, but which links to a name or identifier that doesn't match your real-world name.</p>"},{"location":"01_1_Your_First_XID/#the-power-of-xids","title":"The Power of XIDs","text":"<p>XIDs have a number of advantages over how decentralized identifiers have evolved in the wider ecosystem, as more fully described in \"Musings of a Trust Architect: How XIDs Demonstrate a True Self-Sovereign Identity\". Among those advantages are:</p> <ul> <li>XIDs are Truly Self-Sovereign. A XID is autonomous. It's built on private keys that you control, described in a XID Document that you can update and elide as you see fit. There's no issuer (other than yourself), nor is there a central server that a XID might call home to.</li> <li>XIDs Support Rich Metadata. They can include structured self attestations that describe your skills. Others can also make cryptographically verifiable claims about you through peer attestation.</li> <li>XIDS Allow Elision. You can selectively share different information from your XID with different parties or use progressive trust to expand what you reveal to an individual over time, all while keeping other details private by eliding them. XIDs preserve the cryptographic integrity of the metadata even when portions are removed.</li> <li>XIDs Maintain a Stable Identity. That identity remains stable even if you have multiple keys for different devices and even if you rotate your keys. If something goes wrong, recovery mechanisms let you restore access to your identity (and so your reputation, attestation, and endorsement history).</li> </ul> <p>\ud83d\udd25 *What is the Power of XIDs? The powers of XIDs include true self-sovereignty, rich metadata support, holder-based elision, and ongoing key management.</p>"},{"location":"01_1_Your_First_XID/#part-i-preparing-to-work","title":"Part I: Preparing to Work","text":"<p>Like all of the \"Learning from ...\" courses, \"Learning XIDs from the Command Line\" is intended for hands-on work. By experimenting with XIDs, or even just following along using the envelope-cli app, you'll gain a more visceral understanding of the identifiers and how they can be used.</p> <p>As always, this requires setup: this section will lead you through the installation of a few core applications and later sections will demonstrate how to reload previous work to maintain consistent keys and XIDs throughout the course.</p>"},{"location":"01_1_Your_First_XID/#step-0-setting-up-your-workspace","title":"Step 0: Setting Up Your Workspace","text":"<p>This tutorial depends on <code>bc-envelope-cli</code>, a Rust-based command-line interface. It can be easily installed using the <code>cargo</code> package management tool:</p> <pre><code>cargo install bc-envelope-cli\n</code></pre> <p>Though it's only used for a minor element here, you should also install the Provenance Mark CLI with <code>cargo</code>, as it'll also  be referenced throughout these tutorials:</p> <pre><code>cargo install provenance-mark-cli\n</code></pre> <p>If you don't have <code>cargo</code> installed, see The Cargo Book for easy installation instructions.</p> <p>\u26a0\ufe0f Your Output Will Differ. Tutorial examples show output from the real published BRadvoc8 XID at <code>github.com/BRadvoc8/BRadvoc8</code>. When you follow along, your output will differ. You will have different XID identifiers, different key identifiers, different provenance marks, and different hashes in your envelope.This is expected. Focus on understanding what each step accomplishes, not matching exact output. Additional differences at this level will appear in future tutorials.</p>"},{"location":"01_1_Your_First_XID/#part-ii-creating-the-xid","title":"Part II: Creating the XID","text":"<p>This first tutorial will take you through the basic steps to create a XID. It's deliberately simple. Subsequent tutorials, we'll explore more advanced features including the creation of rich persona structures.</p>"},{"location":"01_1_Your_First_XID/#step-1-create-your-xid","title":"Step 1: Create Your XID","text":"<p>The first step in creating Amira's \"BRadvoc8\" pseudonymous identity is creating a XID as an anchor. </p> <p>\ud83d\udcd6 What is a XID? A XID is an eXtensible IDentifier. It's a Blockchain Commons technology built on Gordian Envelope, which is a smart document system that provides abilities such as elision and encryption, as well as other technologies such as Provenance Marks. XIDs are built to be autonomous cryptographic objects, which means that they can be used without depending on a central server or even a reliable communication network. More details are available in the XID concepts file and the envelope concepts file.</p> <p>A single <code>envelope</code> operation creates a complete XID that contains both private and public keys:</p> <pre><code>XID_NAME=BRadvoc8\nPASSWORD=\"Amira's strong password\"\n\nXID=$(envelope generate keypairs --signing ed25519 \u2502 \\\n    envelope xid new \\\n    --private encrypt \\\n    --encrypt-password \"$PASSWORD\" \\\n    --nickname \"$XID_NAME\" \\\n    --generator encrypt \\\n    --sign inception)\n\nif [ $XID ]\nthen\n  echo \"\u2705 Created your XID: $XID_NAME\"\nelse\n  echo \"\u274c Error in XID creation\"\nfi\n\n\u2502 \u2705 Created your XID: BRadvoc8\n</code></pre> <p>This command runs the <code>envelope</code> CLI twice:</p> <ol> <li><code>envelope generate keypairs</code> creates an Ed25519 keypair (the same algorithm SSH, git, and Signal use). This generates two URs, containing the private and public keys, respectively.</li> <li><code>envelope xid new</code> creates a XID based on that Ed25519 keypair. This generates a XID Document (XIDDoc), which can be read as a Gordian Envelope. We'll usually refer to it just as XID.</li> </ol> <p>\ud83d\udcd6 What is a UR? A UR is a Uniform Resource, another Blockchain Commons technology. It provides a standardized, self-describing way to pass around data such as keys, envelopes, and XIDs.</p> <p>Several arguments to the second command affect how the XID is produced:</p> <ol> <li><code>--private encrypt</code> encrypts the private keys, which are stored in the XID Document, with <code>--encrypt-password</code> allowing decryption with a password.</li> <li><code>--generator encrypt</code> adds an provenance mark to the XID structure, with its secret also encrypted and decryptable with the password.</li> <li><code>--nickname</code> adds an identity label to the XID structure.</li> <li><code>--sign inception</code> wraps and signs the entire XID, allowing others to verify its authenticity.</li> </ol> <p>\u26a0\ufe0f Private Keys on Board: Your XID contains your private keys (encrypted with your password). Though they are encrypted, you should still be wary of distributing a XID that contains those private keys. Fortunately, you can elide (remove) that data, as described below. Obviously, you must also be careful to protect your password.</p> <p>\ud83d\udcd6 What is a Wrapped Envelope? A Gordian Envelope is a package of informational triplets in the form of subject-predicate-object. An assertion (the predicate and the object) always applies to a specific subject. To make an assertion apply to more information, you wrap the envelope and then apply the assertion to the wrapped envelope. Signatures are assertions, so for a signature to apply to an entire envelope (in this case, all of the XID information), the envelope must be wrapped prior to signing.</p> <p>\ud83e\udde0 Learn More. The Signing and Verification concept doc explains the cryptographic details of many of these elements.</p>"},{"location":"01_1_Your_First_XID/#step-2-view-your-xid-structure","title":"Step 2: View Your XID Structure","text":"<p>The <code>envelope format</code> command can always be used to display a human-readable version of any Gordian Envelope, including a XID Document. You can use it to look at Amira's foundational XID:</p> <pre><code>envelope format \"$XID\"\n\n\u2502 {\n\u2502    XID(5f1c3d9e) [\n\u2502         'key': PublicKeys(a9818011, SigningPublicKey(5f1c3d9e, Ed25519PublicKey(b2c16ea3)), EncapsulationPublicKey(96209c0f, X25519PublicKey(96209c0f))) [\n\u2502             {\n\u2502                 'privateKey': ENCRYPTED [\n\u2502                     'hasSecret': EncryptedKey(Argon2id)\n\u2502                 ]\n\u2502             } [\n\u2502                 'salt': Salt\n\u2502             ]\n\u2502             'allow': 'All'\n\u2502             'nickname': \"BRadvoc8\"\n\u2502         ]\n\u2502         'provenance': ProvenanceMark(1896ba49) [\n\u2502             {\n\u2502                 'provenanceGenerator': ENCRYPTED [\n\u2502                     'hasSecret': EncryptedKey(Argon2id)\n\u2502                 ]\n\u2502             } [\n\u2502                 'salt': Salt\n\u2502             ]\n\u2502         ]\n\u2502     ]\n\u2502 } [\n\u2502     'signed': Signature(Ed25519)\n\u2502 ]\n</code></pre> <p>Here's what the individual parts of that \"formatting\" mean:</p> <ul> <li>The curly braces <code>{ }</code> indicate wrapping, which is required for signing.</li> <li>The signature occurs at the end under <code>signed</code>, with the <code>[ ]</code> indicating that it's an assertion on the <code>{ }</code> wrapped envelope. It confirms the entire document is cryptographically signed with the inception key.</li> <li><code>XID(5f1c3d9e)</code> is Amira's unique identifier, derived from her public key. This identifier never changes.</li> <li>The <code>PublicKeys(...)</code> section contains two public keys and is safe to share.</li> <li>The <code>privateKey</code> section has been <code>ENCRYPTED</code>, indicating that the private keys are protected.<ul> <li>The <code>'hasSecret': EncryptedKey(Argon2id)</code> notation notes that the private keys are encrypted with Argon2id, a modern algorithm designed to resist brute-force attacks.</li> <li><code>salt</code> is a random value that further obscures its subject.</li> </ul> </li> <li>The <code>allow</code> statement determines what access these keys have to this identity, as described in key management. By default, keys have total access (<code>All</code>).</li> <li>The <code>nickname</code> is inside the <code>PublicKeys</code> section, not at the top level. That's because a nickname labels a key, not the XID Document. Later keys could have different nicknames while maintaining the same XID identity.</li> <li>The <code>ProvenanceMark(...)</code> is a \"genesis\" mark: the first in a chain that tracks this identity's evolution.</li> <li>The encrypted <code>provenanceGenerator</code> is the secret that created this mark and will create all future marks when Amira publishes new editions of her XID Document.</li> </ul> <p>\ud83d\udcd6 What is a Provenance Mark? A provenance mark is a forward-commitment hash chain. It will be used to record the evolution of this identity, showing that each edition is linked to the previous one (and also, which is the newest edition of the set).</p> <p>Note that a XID actually includes two keypairs that are bundled together: - a <code>Signing</code> keypair for creating and verifying signatures.    - Your <code>SigningPublicKey</code> is also called your \"inception key\" because your XID identifier (<code>XID(5f1c3d9e)</code>) is the SHA-256 hash of this signing key. Hence the name: it's the key that defines your XID. Your identifier never changes because it's permanently bound to this original key. - an <code>Encapsulation</code> keypair for encryption and decryption.</p> <p>As shown, the public halves of the keypairs are readable by anyone, while the private halves are encrypted with your password. This mirrors how SSH works with <code>id_rsa</code> and <code>id_rsa.pub</code>, except your XID bundles both into a single document.</p> <p>\u26a0\ufe0f The Signing Key Defines the Identity. The same keypairs always produce the same XID identifier because the identifier is derived from the public key. If you regenerate from the same keys, you get the same identity. If you lose the keys, you lose the identity, just as with SSH.</p>"},{"location":"01_1_Your_First_XID/#a-review-of-envelope-structure","title":"A Review of Envelope Structure","text":"<p>If you are familiar with envelope structure (discussed here) and envelope format (discussed below), then you can skip ahead to Step 3 and create a public view of Amira's XID. If, however, you are not that familiar with Gordian Envelope, then read on.</p> <p>As noted, every envelope has a subject (the main thing) and assertions (claims about that thing), which each include a predicate and an object. This usually means the subject predicates the object or the subject has a predicate of the object.</p> <p>Here's how that structure appears in the sample XID Document:</p> <pre><code>{\n   XID(5f1c3d9e) [                         \u2190 SUBJECT\n    [\n        'key': PublicKeys(...)             \u2190 ASSERTION (predicate: object)\n        'provenance': ProvenanceMark(...)  \u2190 ASSERTION (predicate: object)\n    ]\n}\n</code></pre> <p>The XID identifier <code>XID(5f1c3d9e)</code> is the subject. The assertions make claims about it: \"this XID has these public keys\" and \"this XID has this provenance history.\" Assertions can be added, removed, or hidden independently, no matter where they are in an envelope document. This is a key insight for their usage (and in fact you'll be hiding individual assertions momentarily).</p> <p>This pattern nests. Look inside the <code>'key'</code> assertion:</p> <pre><code>'key': PublicKeys(a9818011...) [   \u2190 SUBJECT of this nested envelope\n    'allow': 'All'                 \u2190 ASSERTION about the key\n    'privateKey': ENCRYPTED        \u2190 Another ASSERTION\n]\n</code></pre> <p>The <code>PublicKeys</code> object is itself a subject with its own assertions. It <code>allow</code>s all access to the XID and it contains an <code>ENCRYPTED</code> <code>privateKey</code>. This recursive structure lets you build arbitrarily rich identity documents, constrained by the specific requirements of the XID format. In chapter 2, for example, you'll add new keys, and in chapter 3 you'll use the <code>edge</code> assertion to add peer endorsements.</p>"},{"location":"01_1_Your_First_XID/#a-review-of-envelope-format","title":"A Review of Envelope Format","text":"<p>Envelope format (output with <code>envelope format</code>) displays abbreviated labels for some data such as <code>PublicKeys(32de0f2b)</code> and <code>ENCRYPTED</code> rather than raw cryptographic data. This is intentional: showing hundreds of bytes of base64 would obscure the structure. Envelope format also hides complexity: <code>PublicKeys</code> actually contains two separate keys (a signing key and an encapsulation key), <code>ENCRYPTED</code> contains the ciphertext plus Argon2id parameters, and <code>Salt</code> contains random bytes that make each XIDDoc's digest unique. You don't need to see this detail to work with XIDs, but knowing it's there helps when things go wrong.</p> <p>The hex codes in parentheses are digest fragments that let you quickly identify which key or encrypted blob you're looking at. Each one is a hash of the data in question. For example, the following shows all the keys in a XID, with their hashes. (Note that the hash of the <code>SigningPublicKey</code>, <code>5f1c3d9e</code>, is the same as your XID! That's correct: as discussed elsewhere, the XID is the hash of your signing key!)</p> <pre><code>         'key': PublicKeys(a9818011, SigningPublicKey(5f1c3d9e, Ed25519PublicKey(b2c16ea3)), EncapsulationPublicKey(96209c0f, X25519PublicKey(96209c0f))) [\n</code></pre> <p>The other thing of particular note is the quoted data. There are two styles of quotes:</p> <ul> <li>Single quotes (<code>'key'</code>, <code>'nickname'</code>, <code>'All'</code>) designate Known Values. These are standardized terms from the Known Values registry. They can be subjects, predicates (<code>'allow'</code>), or objects (<code>'All'</code>). These ensure different tools each understand your XID in the same way.</li> <li>Double quotes (<code>\"BRadvoc8\"</code>, <code>\"github\"</code>) designate Strings. This is custom application data you define.</li> </ul>"},{"location":"01_1_Your_First_XID/#step-3-create-a-public-view-of-your-xid-with-elision","title":"Step 3: Create a Public View of Your XID with Elision","text":"<p>Amira's XID is not ready for publication yet. You're going to add some more information in \u00a71.2 before sending it to Amira's first contact, Ben. But to prepare yourself for that, you're going to go over the crical step that would be required to publish a XID: creating a public view.</p> <p>When you create a shareable public view of a XID, you are engaging in data minimization. You're creating a new way to look at the current edition of your XID that only includes the data that your recipient needs to see. This is \"selective disclosure.\" Now, there's not a lot of information yet in Amira's XID, but there's one thing that we don't need to send out: her private key. Sure, it's encrypted, but sending it out creates an attack surface and that could be avoided with use of envelope's elision (removal) feature.</p> <p>To remove content from a XID requires finding the hash for that data. Every thing in an envelope has a hash: it's how the envelope is built and how it maintains signatures (more on that momentarily). Once you find the right hash, you simply tell the Envelope CLI to remove the data represented by that particular data. So to remove the private key you need to first find its hash in your envelope.</p> <p>\ud83d\udcd6 What is a View? A view is a version of a XID that has been elided in a specific way. The XID itself isn't changed: every view of the same XID has the same root hash. However, what's visible will be different from one view to another.</p> <p>Find the Private Key Digest:</p> <p>In a graphical UI, this whole process might be as simple as clicking on the private-key assertion in the envelope and hitting the DELETE key. In the Envelope CLI, it takes digging down through the layers of the envelope by unwrapping wrapped envelopes and finding assertions within them.</p> <p>This requires knowing how the envelope is structured:</p> <pre><code>\u2502 {\n\u2502    XID(5f1c3d9e) [\n\u2502         'key': PublicKeys(a9818011, SigningPublicKey(5f1c3d9e, Ed25519PublicKey(b2c16ea3)), EncapsulationPublicKey(96209c0f, X25519PublicKey(96209c0f))) [\n\u2502             {\n\u2502                 'privateKey': ENCRYPTED [\n\u2502                     'hasSecret': EncryptedKey(Argon2id)\n\u2502                 ]\n\u2502             }\n\u2502 ...\n\u2502   ]\n\u2502 }\n</code></pre> <p>This shows that we need to unwrap the envelope (since it was wrapped and signed with <code>--sign inception</code>), then find the <code>'key'</code> assertion, and then find the <code>'privateKey'</code> assertion.</p> <p>Unwrapping is done with <code>extract wrapped</code>.</p> <pre><code>UNWRAPPED_XID=$(envelope extract wrapped \"$XID\")\n</code></pre> <p>Then you find the <code>key</code> predicate, which is a <code>known</code> value, and extract its <code>PublicKeys</code> object:</p> <pre><code>KEY_ASSERTION=$(envelope assertion find predicate known key \"$UNWRAPPED_XID\")\nKEY_OBJECT=$(envelope extract object \"$KEY_ASSERTION\")\n</code></pre> <p>Finally, you find the known-value <code>privateKey</code> assertion in that and then record its digest:</p> <pre><code>PRIVATE_KEY_ASSERTION=$(envelope assertion find predicate known privateKey \"$KEY_OBJECT\")\nPRIVATE_KEY_DIGEST=$(envelope digest \"$PRIVATE_KEY_ASSERTION\")\n\nif [ $PRIVATE_KEY_DIGEST ]\nthen\n  echo \"\u2705 Found private key digest\"\nelse\n  echo \"\u274c Error in private key retrieval\"\nfi\n\n\u2502 \u2705 Found private key digest\n</code></pre> <p>Elide Your XID:</p> <p>Eliding your private key from your XID to create a public view simply requires using the <code>elide</code> command to remove the data represented by that digest:</p> <pre><code>PUBLIC_XID=$(envelope elide removing \"$PRIVATE_KEY_DIGEST\" \"$XID\")\necho \"\u2705 Created public view by eliding private key\"\n\n\u2502 \u2705 Created public view by eliding private key\n</code></pre> <p>Afterward, you can examine this new public view of your XID:</p> <pre><code>envelope format \"$PUBLIC_XID\"\n\n\u2502 {\n\u2502     XID(5f1c3d9e) [\n\u2502         'key': PublicKeys(a9818011, SigningPublicKey(5f1c3d9e, Ed25519PublicKey(b2c16ea3)), EncapsulationPublicKey(96209c0f, X25519PublicKey(96209c0f))) [\n\u2502             'allow': 'All'\n\u2502             'nickname': \"BRadvoc8\"\n\u2502             ELIDED\n\u2502         ]\n\u2502         'provenance': ProvenanceMark(1896ba49) [\n\u2502             {\n\u2502                 'provenanceGenerator': ENCRYPTED [\n\u2502                     'hasSecret': EncryptedKey(Argon2id)\n\u2502                 ]\n\u2502             } [\n\u2502                 'salt': Salt\n\u2502             ]\n\u2502         ]\n\u2502     ]\n\u2502 } [\n\u2502     'signed': Signature(Ed25519)\n\u2502 ]\n</code></pre> <p>It looks identical except the <code>privateKey</code> section is gone, replaced with <code>ELIDED</code>. Also of note is the fact that this formatting implies that the signature has been preserved, despite removing some of the data in the envelope. That's accurate: this is a purposeful feature of Gordian Envelope.</p>"},{"location":"01_1_Your_First_XID/#a-review-of-envelope-hashes-signatures","title":"A Review of Envelope Hashes &amp; Signatures","text":"<p>If you are already comfortable with the structure of Gordian Envelopes, how they hash data, and how data is signed, skip down to Part II.  Otherwise, here's the skinny on how that signature is preserved even after you elided information:</p> <p>Gordian Envelope is built on hashes. Every subject, every predicate, every object, and every assertion has a hash. Leaves (such as subject, predicates, and objects) have hashes of the content of that leaf, while nodes (such as the top-level of your envelope, assertions, collections of a subject and assertions, and wrapped content) have hashes that are built from the hashes of the objects they contain. A signature is made not across the content of an envelope, but against the root (or top-level) hash of an envelope.</p> <p>Here's what a fragment of that looks like, generated with <code>envelope format --type tree $XID</code>, which shows abbreviations of all the hashes in an envelope:</p> <pre><code>1da62441 NODE                                                \u2190 ROOT Hash (1da62441)\n    34446925 subj WRAPPED                                    \u2190 Wrapped Envelope Hash (34446925)\n        bc6369ae cont NODE                                   \u2190 Subject + Assertion(s) Node Hash (bc6369ae)\n            2b2d09ab subj XID(5f1c3d9e)                      \u2190 XID Subject Hash (2b2d09ab)\n            e0c2825c ASSERTION                               \u2190 Provenance Assertion Hash (e0c2825c)\n                c1736fc8 pred 'provenance'\n                c38203ae obj NODE\n                    53da07ce subj ProvenanceMark(1896ba49)\n                    9a0110e6 ELIDED\n    ...\n    d5625d76 ASSERTION                                        \u2190 Signature Assertion Hash (d5625d76)\n        d0e39e78 pred 'signed'\n        91ccf7a3 obj Signature(Ed25519)\n</code></pre> <p>The root node has an (abbreviated) hash of <code>1da62441</code>, which is built from the wrapped subject hash of <code>34446925</code> and the signature assertion hash of <code>d5625d76</code>. The wrapped envelope's hash is built from the node hash of <code>bc6369ae</code>, which is built from the XID subject hash of <code>2b2d09ab</code> and a string of assertions attached to that subject, the first of which is provenance assertion, which has a hash of <code>e0c2825c</code>. Etc.</p> <p>When data is elided from an envelope, its content is removed, but the hash remains. That means that all of the node hashes above that leaf hash remain the same, including the root hash. Since it's the root hash that is signed, not the full envelope content, the signature remains valid.</p> <p>The above example shows a new elision, of the secret within the provenance mark assertion. Making a further elision of the entire provenance mark assertion demonstrates that the upper-level hashes remain in place:</p> <pre><code>1da62441 NODE                                                \u2190 ROOT Hash (still 1da62441)\n    34446925 subj WRAPPED                                    \u2190 Wrapped Envelope Hash (still 34446925)\n        bc6369ae cont NODE                                   \u2190 Subject + Assertion(s) Node Hash (still bc6369ae)\n            2b2d09ab subj XID(5f1c3d9e)                      \u2190 XID Subject Hash (2b2d09ab)\n            e0c2825c ELIDED                                  \u2190 Elided (Provenance Assertion) Hash (still e0c2825c)\n    ...\n    d5625d76 ASSERTION                                        \u2190 Signature Assertion Hash (d5625d76)\n        d0e39e78 pred 'signed'\n        91ccf7a3 obj Signature(Ed25519)\n\n</code></pre> <p>\u26a0\ufe0f The Root Hash is Not the ID Identifier. The root hash is composed from the hashes of all the data within an envelope. It changes if you change the document. It's an identifier for all views of a specific edition of your XID Document. In contrast, the XID identifier is the hash of your inception public key. It never changes. It's an identifier for all editions of your XID Document (or if you prefer: it's the identifier for your identity).</p> <p>You can verify your root hash does not change after you elide data with the <code>envelope digest</code> command:</p> <pre><code>ORIGINAL_DIGEST=$(envelope digest \"$XID\")\nPUBLIC_DIGEST=$(envelope digest \"$PUBLIC_XID\")\n\necho \"Original XID digest: $ORIGINAL_DIGEST\"\necho \"Public XID digest:   $PUBLIC_DIGEST\"\n\nif [ \"$ORIGINAL_DIGEST\" = \"$PUBLIC_DIGEST\" ]; then\n    echo \"\u2705 VERIFIED: Digests are identical - elision preserved the root hash\\!\"\nelse\n    echo \"\u274c ERROR: Digests differ\"\nfi\n\n\u2502 Original XID digest: ur:digest/hdcxcaoldkfpisoesfoxdnatamwyytasdwsbuomnkicxlbaavehsfzksmdinrogachhnsolbpahg\n\u2502 Public XID digest:   ur:digest/hdcxcaoldkfpisoesfoxdnatamwyytasdwsbuomnkicxlbaavehsfzksmdinrogachhnsolbpahg\n\u2502 \u2705 VERIFIED: Digests are identical - elision preserved the root hash!\n</code></pre> <p>The digests are identical. You removed the private key, yet the hash didn't change. </p>"},{"location":"01_1_Your_First_XID/#part-iii-verifying-a-xid","title":"Part III: Verifying a XID","text":"<p>One of the powers of a XID is that it can be verified in various ways (though that doesn't necessarily mean someone is who they say they are, as is described in \"What We Proved\" in future sections).</p>"},{"location":"01_1_Your_First_XID/#step-4-verify-the-xid","title":"Step 4: Verify the XID","text":"<p>You also want to test out the verification of your XID, as that'll be crucial when you actually publish it. There are two ways to do so:</p> <ul> <li>The signature can be verified.</li> <li>The provenance mark can be validated.</li> </ul> <p>A digital signature is verified against a public key. For a XID, that's the public signing key.</p> <p>After publication, a public key might also be retrieved from a PKI or other publication site. But for this tutorial, yyou have to dig down through the envelope to get to it:</p> <pre><code>UNWRAPPED_XID=$(envelope extract wrapped \"$XID\")\nKEY_ASSERTION=$(envelope assertion find predicate known key \"$UNWRAPPED_XID\")\nKEY_OBJECT=$(envelope extract object \"$KEY_ASSERTION\")\nPUBLIC_KEYS=$(envelope extract ur \"$KEY_OBJECT\")\n</code></pre> <p>You can then use envelope's <code>verify</code> command to verify the signature of the <code>PUBLIC_XID</code> against that public key:</p> <pre><code>envelope verify -v \"$PUBLIC_KEYS\" \"$PUBLIC_XID\" &gt;/dev/null &amp;&amp; echo \"\u2705 Signature verified\\!\"\n\n\u2502 \u2705 Signature verified!\n</code></pre> <p>This confirms that this XID Document has been signed by the owner of the public key within the document (in other words, it verifies that the creator of the XID Document actually owns the key that is advertising in the document).</p> <p>If the public key was published, it would confirm that the document was signed by the owner of that published public key.</p> <p>When the XID is later published, this verification will also demonstrate that updates of this XID Document continue to be signed by this original (inception) key or by a new key that has been authorized by the inception key, possibly through a chain of authorizations.</p>"},{"location":"01_1_Your_First_XID/#step-5-verify-the-provenance-mark","title":"Step 5: Verify the Provenance Mark","text":"<p>The provenance mark can also be verified. To do this, extract the Provenance Mark with the <code>xid provenance</code> command:</p> <pre><code>PROVENANCE_MARK=$(envelope xid provenance get \"$PUBLIC_XID\")\n</code></pre> <p>Now you can validate the Provenance Mark with the provenance mark CLI:</p> <pre><code>provenance validate \"$PROVENANCE_MARK\"\n\n\u2502 \u2705 (silent success - provenance check passed!)\n</code></pre> <p>By default, <code>provenance validate</code> offers no response if the provenance mark is valid. But you can use <code>--format json-pretty</code> to get more information:</p> <pre><code>provenance validate --format json-pretty \"$PROVENANCE_MARK\"\n\n\u2502 {\n\u2502   \"marks\": [\n\u2502\n\u2502 \"ur:provenance/lfaxhdimhspdzshnfrkbrngrpmkgrodlsklpluntgozcoeisbyvyatbdfytpaxinfdjzidaomdflcywmfewnuejnmugucmrkhdonvdbgwneejthecyuehnsnjphtuednttsfrptsidurgwfxldgelpecmecyjoetieytfrhkgtfdestnnlqzmoaheeemselpbdwnwnsbjnnertpmrdnnbdhtdkpdwfkihgwy\"\n\u2502   ],\n\u2502   \"chains\": [\n\u2502     {\n\u2502       \"chain_id\": \"61a8fa603b7ebe4bad7bb82fc5858b9d55fda26811e1070b44d80369486c6202\",\n\u2502       \"has_genesis\": true,\n\u2502       \"marks\": [\n\u2502\n\u2502 \"ur:provenance/lfaxhdimhspdzshnfrkbrngrpmkgrodlsklpluntgozcoeisbyvyatbdfytpaxinfdjzidaomdflcywmfewnuejnmugucmrkhdonvdbgwneejthecyuehnsnjphtuednttsfrptsidurgwfxldgelpecmecyjoetieytfrhkgtfdestnnlqzmoaheeemselpbdwnwnsbjnnertpmrdnnbdhtdkpdwfkihgwy\"\n\u2502       ],\n\u2502       \"sequences\": [\n\u2502         {\n\u2502           \"start_seq\": 0,\n\u2502           \"end_seq\": 0,\n\u2502           \"marks\": [\n\u2502             {\n\u2502               \"mark\":\n\u2502 \"ur:provenance/lfaxhdimhspdzshnfrkbrngrpmkgrodlsklpluntgozcoeisbyvyatbdfytpaxinfdjzidaomdflcywmfewnuejnmugucmrkhdonvdbgwneejthecyuehnsnjphtuednttsfrptsidurgwfxldgelpecmecyjoetieytfrhkgtfdestnnlqzmoaheeemselpbdwnwnsbjnnertpmrdnnbdhtdkpdwfkihgwy\",\n\u2502               \"issues\": []\n\u2502             }\n\u2502           ]\n\u2502         }\n\u2502       ]\n\u2502     }\n\u2502   ]\n\u2502 }\n</code></pre> <p>This says very little so far, but that's to be expected: the power of provenance marks is in seeing that multiple published editions of documents are related\u2014and you haven't even published a single version of Amira's XID yet! Nonethless, you can see from <code>has_genesis: true</code>, <code>start_seq: 0</code>, and <code>end_seq: 0</code> that this is the first edition in the provenance mark chain (the \"genesis mark\"), with no issues found. This will become more meaningful in chapter 2 when you produce a second edition of Amira's XID for publication, and advance the provenance mark as a result.</p> <p>Before you close out your verification it's worth noting that all verification was down with the public view of the XID; no secret information was needed. This asymmetry is common in cryptography: Amira creates information with her secrets, and only she can update that information. But after she distributes her public XID, anyone can check it.</p>"},{"location":"01_1_Your_First_XID/#part-iv-storing-your-files","title":"Part IV: Storing Your Files","text":"<p>This course will frequently store copies of files for future usage. But, we're not quite there yet because we'll be finishing up the initial edition of Amira's XID in the next section.</p> <p>For now, we're instead going to talk about how Amira might organize her files for their real-world usage.</p>"},{"location":"01_1_Your_First_XID/#step-6-organize-your-files","title":"Step 6: Organize Your Files","text":"<p>A XID can be output to a file just be echoing the XID into a file:</p> <pre><code>echo $XID &gt; BRadvoc8-xid.envelope\necho $PUBLIC_XID &gt; BRadvoc8-xid-public.envelope\n</code></pre> <p>The complete <code>BRadvoc8-xid.envelope</code> file contains everything: private keys (encrypted), public keys, nickname, provenance, and signature. If you lose this file without a backup, you lose your identity, just like losing <code>id_rsa</code>. Unlike SSH keys, your XID also includes identity metadata (nickname, permissions, provenance history), making it a complete, self-contained identity document rather than just raw key material.</p> <p>There might be many different public views of your current XID, of which <code>BRadvoc8-xid-public.envelope</code> would be just one, with each view elided in different ways. Obviously, you'll want to keep your private key out of all of them, but you might also decide to reveal different information to different people, as part of selective disclosure.</p> <p>Formatted outputs can similarly be output:</p> <pre><code>envelope format $XID &gt; BRadvoc8-xid.format\nenvelope format $PUBLIC_XID &gt; BRadvoc8-xid-public.format\n</code></pre> <p>For real-world usage, Amira will organize her files in a dedicated directory. The pattern mirrors SSH: <code>BRadvoc8-xid.envelope</code> is like <code>id_rsa</code> (keep secret), and <code>BRadvoc8-xid-public.envelope</code> is like <code>id_rsa.pub</code> (safe to share).</p> <pre><code>xid-5f1c3d9e/\n\u251c\u2500\u2500 BRadvoc8-xid.envelope          # Complete XID with encrypted private keys\n\u251c\u2500\u2500 BRadvoc8-xid.format            # Human-readable view\n\u251c\u2500\u2500 BRadvoc8-xid-public.envelope   # Public XID (private keys elided)\n\u2514\u2500\u2500 BRadvoc8-xid-public.format     # Human-readable view\n</code></pre> <p>Having offered this real-world example, we're going to move over to a more tutorial-specific format for storing files in the next tutorial. (For now, make sure you have either your full envelope file or that envelope still stored in a <code>$XID</code> variable as you continue into the next section.)</p>"},{"location":"01_1_Your_First_XID/#summary-the-bigger-picture","title":"Summary: The Bigger Picture","text":"<p>What Amira created is more than a keypair. She created the BRadvoc8 identity, which is fully under her control. No service provider issued it and no platform can suspend it. The encrypted XID depends on no centralized structure. Because it's a self-contained cryptographic object, the XID can live anywhere: on a USB drive, in email, in cloud storage, even printed as a QR code. The infrastructure is in the document itself, not in some external system. This is self-sovereign identity: Amira owns the keys and the resulting document.</p> <p>Amira's XID implements pseudonymity rather than anonymity, and that's exactly what she wants. Anonymous contributions lack credibility; project maintainers can't trust them. But BRadvoc8 can build reputation over time through verifiable contributions while protecting Amira's real-world identity. It's the same model authors use with pen names: Mark Twain built a reputation while Samuel Clemens stayed private.</p> <p>Though you experimented with elision and verification, you haven't actually published Amira's XID. More on that in the next tutorial!</p>"},{"location":"01_1_Your_First_XID/#exercises","title":"Exercises","text":"<p>Try these to solidify your understanding:</p> <ul> <li>Create your own XID with a pseudonym of your choice.</li> <li>Experiment with different passwords.</li> <li>Practice creating public views by eliding private keys, then verify the signatures still work on the elided views.</li> <li>Save your XID to a file and reload it to confirm nothing was lost.</li> </ul>"},{"location":"01_1_Your_First_XID/#whats-next","title":"What's Next","text":"<p>Since XIDs are autonomous, Amira needs a way to assure people that they have an up-to-date verison. Doing that (and publishing that XID) is the topic of \u00a71.2: Making a XID Verifiable.</p>"},{"location":"01_1_Your_First_XID/#example-script","title":"Example Script","text":"<p>A complete working script implementing this tutorial is available at <code>../tests/01-your-first-xid-TEST.sh</code>. Run it to see all steps in action:</p> <pre><code>bash tests/01-your-first-xid-TEST.sh\n</code></pre> <p>This script will create all the files shown in the File Organization section (below) with proper naming conventions and directory structure.</p>"},{"location":"01_1_Your_First_XID/#appendix-i-key-terminology","title":"Appendix I: Key Terminology","text":"<p>Assertion - A predicate-object pair in an envelope, making a claim about the subject (e.g., <code>'key': PublicKeys(...)</code>).</p> <p>Edition - A version of a XIDDoc (or other envelope) that is different from previous editions due to the addition, removal, or update of information. An edition may have many views, which selectively elide information from the master document. If an envelope contains a provenance mark, it is incremented when a new edition is created.</p> <p>Elision - Removing data from an envelope while preserving the envelope's root hash, enabling selective disclosure while maintaining cryptographic integrity.</p> <p>Envelope - Gordian Envelope, a smart-document system that supports the deterministic storage of data and its distribution in multiple selectively disclosed views to support data minimization. </p> <p>Envelope Digest - The root hash of an envelope structure, preserved across elision, enabling signature verification on different views of the same document.</p> <p>Inception Key - The signing public key that defines your XID from the beginning. Your XID identifier is the SHA-256 hash of this key's CBOR representation. The term \"inception\" emphasizes that this key establishes the identity at its origin.</p> <p>Known Value - Standardized term from the Known Values registry, shown in single quotes. Can be a subject, a predicate, or an object.</p> <p>Provenance Generator - The secret that creates provenance marks. It created your genesis mark and will create all future marks when you publish new XIDDoc editions. Separate from the inception key.</p> <p>Provenance Mark - Cryptographic marker establishing the sequence position of a document edition, forming a verifiable chain of identity evolution. The genesis mark (sequence 0) is the first in the chain. Provides ordering, not timestamps.</p> <p>Root Hash \u2014 The unique identifier for a specific edition of an envelope, calculated based on all the data in the envelope. Persistent across all views of an edition, but not across multiple editions of an envelope.</p> <p>Selective Disclosure - Sharing only the information needed for a specific context. Sign once, create multiple views by eliding different parts, and every view verifies against the same signature.</p> <p>String - Custom application data, shown in double quotes (<code>\"BRadvoc8\"</code>, <code>\"github\"</code>).</p> <p>Subject - The main thing an envelope describes; in XIDDocs, this is the XID identifier.</p> <p>View - A version of a specific edition of a XIDDoc (or other envelope) that has been elided in a specific way, to preserve selective disclosure. Despite the elision, signatures remain valid, because they are made across the Root Hash.</p> <p>XID (eXtensible IDentifier) - The unique identifier for your identity, calculated as the SHA-256 hash of your inception signing public key. Persistent across all document editions because it's bound to that original key.</p> <p>XIDDoc (XID Document) - The envelope document containing an XID and its assertions (keys, provenance, metadata). This is what you create, update, and share.</p>"},{"location":"01_1_Your_First_XID/#appendix-ii-common-questions","title":"Appendix II: Common Questions","text":""},{"location":"01_1_Your_First_XID/#q-what-if-i-lose-my-xid-file","title":"Q: What if I lose my XID file?","text":"<p>A: If you lose your <code>BRadvoc8-xid.envelope</code> file without a backup, you lose your identity. This is just like losing your SSH <code>id_rsa</code> file. There's no recovery mechanism without a backup, so make sure to store encrypted copies in multiple secure locations.</p>"},{"location":"01_1_Your_First_XID/#q-can-i-use-this-xid-on-multiple-devices","title":"Q: Can I use this XID on multiple devices?","text":"<p>A: Yes! Copy your <code>BRadvoc8-xid.envelope</code> file to other devices. Since the private keys are encrypted, the file is reasonably safe to sync via cloud storage (as long as you have a strong password!). The XID identifier stays the same regardless of which device you're using. </p> <p>You can also create device-specific keys and delegate permissions, allowing each device to have its own key while maintaining a single XID identity. More on this in future tutorials.</p>"},{"location":"01_1_Your_First_XID/#q-what-if-i-need-to-revoke-my-keys","title":"Q: What if I need to revoke my keys?","text":"<p>A: Unlike with SSH keys, you can revoke a key pair while keeping your XID persistent.</p>"},{"location":"01_1_Your_First_XID/#q-why-is-signing-done-with-ed25519-instead-of-schnorr-or-other-algorithms","title":"Q: Why is signing done with Ed25519 instead of Schnorr or other algorithms?","text":"<p>A: Ed25519 is the industry standard (SSH, git, Signal) with wide compatibility and excellent security. Advanced users can use other algorithms (<code>--signing schnorr</code>, <code>--signing ecdsa</code>, <code>--signing mldsa44</code>), but Ed25519 is recommended for beginners.</p>"},{"location":"01_2_Making_a_XID_Verifiable/","title":"1.2: Making a XID Verifiable","text":"<p>This section demonstrates how to maintain a XID's freshness without direct communication through the use of a publication URL.</p> <p>\ud83e\udde0 Related concepts. This tutorial introduces verification and freshness. To understand the underlying principles, see Progressive Trust for how trust builds incrementally, and Data Minimization for controlling what you disclose when publishing.</p>"},{"location":"01_2_Making_a_XID_Verifiable/#objectives-for-this-section","title":"Objectives for this Section","text":"<p>After working through this section, a developer will be able to:</p> <ul> <li>Create a <code>dereferenceVia</code> assertion pointing to a fresh version of a XID.</li> <li>Publish a XID.</li> <li>Check that a <code>dereferenceVia</code> assertion matches the fetch URL.</li> <li>Assess what has been proven and what trust level that supports.</li> </ul>"},{"location":"01_2_Making_a_XID_Verifiable/#amiras-story-the-freshness-problem","title":"Amira's Story: The Freshness Problem","text":"<p>After \u00a71.1, Amira could give Ben her public XID directly. She could email it, share it via Signal, or do whatever else works. But what happens when she updates her XID next month? Ben has no way to know his copy is stale. He might verify signatures against outdated information, not knowing that Amira added new attestations or rotated keys.</p> <p>One simple solution is to publish a XID a stable URL and embed that URL in the document itself. (We'll discuss other solutions in a future tutorial.) Now Ben can fetch the current version whenever he needs it and verify through the URL (andlater through provenance marks) that his copy is actually current, not an old snapshot someone gave him.</p> <p>This isn't about discovery (how Ben finds Amira's XID in the first place). It's about freshness (how Ben verifies he has the current version).</p>"},{"location":"01_2_Making_a_XID_Verifiable/#part-i-publishing-a-xid","title":"Part I: Publishing a XID","text":"<p>You'll add a publication URL to Amira's XID and then publish a public view of that.</p>"},{"location":"01_2_Making_a_XID_Verifiable/#step-0-verify-dependencies","title":"Step 0: Verify Dependencies","text":"<p>Before you start, ensure that you have the required CLI tools from Tutorial 01:</p> <pre><code>envelope --version\nprovenance --version\n\n\u2502 bc-envelope-cli 0.34.1\n| provenance-mark-cli 0.7.0\n</code></pre> <p>If either tool is not installed, see Step 0 of \u00a71.1 for installation instructions.</p>"},{"location":"01_2_Making_a_XID_Verifiable/#step-1-load-your-xid","title":"Step 1: Load Your XID","text":"<p>To reload your XID, first be sure to recreate your environmental variables:</p> <pre><code>XID_NAME=\"BRadvoc8\"\nPASSWORD=\"Amira's strong password\"\n</code></pre> <p>If you saved your XID to a file, you can now load it:</p> <pre><code>XID=$(cat xid-*/BRadvoc8-xid.envelope)\n</code></pre> <p>Else, recreate it for this tutorial:</p> <pre><code>XID=$(envelope generate keypairs --signing ed25519 | \\\n    envelope xid new \\\n    --private encrypt \\\n    --encrypt-password \"$PASSWORD\" \\\n    --nickname \"$XID_NAME\" \\\n    --generator encrypt \\\n    --sign inception)\necho \"\u2705 Loaded XID: $XID_NAME\"\n</code></pre> <p>Afterward, you can check that it loaded correctly with <code>envelope format</code>:</p> <pre><code>envelope format \"$XID\" | head -10\n\n\u2502 {\n\u2502     XID(5f1c3d9e) [\n\u2502         'key': PublicKeys(a9818011, SigningPublicKey(5f1c3d9e, Ed25519PublicKey(b2c16ea3)), EncapsulationPublicKey(96209c0f, X25519PublicKey(96209c0f))) [\n\u2502             {\n\u2502                 'privateKey': ENCRYPTED [\n\u2502                     'hasSecret': EncryptedKey(Argon2id)\n\u2502                 ]\n\u2502             } [\n\u2502                 'salt': Salt\n\u2502             ]\n\u2502 ...\n</code></pre>"},{"location":"01_2_Making_a_XID_Verifiable/#step-2-choose-your-publication-url","title":"Step 2: Choose Your Publication URL","text":"<p>You now must decide where to publish Amira's XID.  For this tutorial, we'll use a GitHub repository, but any stable URL website or IPFS gateway will work, just be sure that it's something that you personally control, since one of the advantages of your XID is that it's self-sovereign (meaning that it's controlled by you).</p> <pre><code>PUBLISH_URL=\"https://github.com/BRadvoc8/BRadvoc8/raw/main/xid.txt\"\n</code></pre> <p>\u26a0\ufe0f Raw Content Required. Your URL must point to raw content, not an HTML page.  If verifiers fetch an HTML page instead of the actual XID data, verification will fail. For GitHub repositories, use the <code>/raw/</code> URL path for web access or the <code>raw.githubusercontent.com</code> site name for curl access (see below).</p>"},{"location":"01_2_Making_a_XID_Verifiable/#step-3-add-a-dereferencevia-assertion","title":"Step 3: Add a <code>dereferenceVia</code> Assertion","text":"<p>You now need to link your publication URL to Amira's XID. This is done by adding a <code>dereferenceVia</code> URL, which says how to \"resolve\" the XID. Passing the original <code>$XID</code> to the <code>xid resolution add</code> command will do this:</p> <pre><code>XID_WITH_URL=$(envelope xid resolution add \\\n    \"$PUBLISH_URL\" \\\n    --verify inception \\\n    --password \"$PASSWORD\" \\\n    --sign inception \\\n    --private encrypt \\\n    --generator encrypt \\\n    --encrypt-password \"$PASSWORD\" \\\n    \"$XID\")\n</code></pre> <p>This command uses the following new arguments:</p> <ol> <li>The <code>$PUBLISH_URL</code> is of course required by <code>xid resolution add</code>.</li> <li><code>--verify inception</code> says to verify that the signature of the original <code>$XID</code> was made with its inception key.</li> <li><code>--password \"$PASSWORD\"</code> decrypts the previously encrypted information with the <code>$PASSWORD</code>.</li> </ol> <p>You want the new, updated XID to have the same protections as the original, so you also repeat the various encryption and signature commands as part of the creation for Amira's updated XID:</p> <ol> <li><code>--private encrypt</code> to encrypt the private key.</li> <li><code>--generate encrypt</code> to encrypt the provenance mark generate.</li> <li><code>--encrypt-password</code> to use the <code>$PASSWORD</code> in future decryption.</li> <li><code>--sign</code> to sign the new document.</li> </ol> <p>Note that you didn't have to repeat commands like <code>--nickname</code>. That's because the whole previous XID was read in. You just had to redo the encryption and signing at the end.</p> <p>\ud83d\udcd6 What is an Edition? An edition is a new version of a XID that contains new content (or has removed old content). It will have a different root hash, but the XID identifier always stays the same. This is different from a new view, which is a new way to look at an existing edition.</p> <p>Whenever you make one or more updates to a XID in preparation for publication of a new edition, you should ask: \"Has the previous version of the XID been published?\" If the answer is \"yes\" then you should update the provenance mark, to take advantage of its ability to order editions of a XID (and so tell recipients which one is the most up to date). In this case, you never published the previous version of the XIDDoc, so there's no need to update. When this one is published it'll be the first (sequence 0) edition.</p> <p>You can use <code>envelope format</code> to see what your updated XID looks like:</p> <pre><code>envelope format \"$XID_WITH_URL\"\n\n\u2502 Added dereferenceVia\n\u2502 {\n\u2502     XID(5f1c3d9e) [\n\u2502         'dereferenceVia': URI(https://github.com/BRadvoc8/BRadvoc8/raw/main/xid.txt)\n\u2502         'key': PublicKeys(a9818011, SigningPublicKey(5f1c3d9e, Ed25519PublicKey(b2c16ea3)), EncapsulationPublicKey(96209c0f, X25519PublicKey(96209c0f))) [\n\u2502             {\n\u2502                 'privateKey': ENCRYPTED [\n\u2502                     'hasSecret': EncryptedKey(Argon2id)\n\u2502                 ]\n\u2502             } [\n\u2502                 'salt': Salt\n\u2502             ]\n\u2502             'allow': 'All'\n\u2502             'nickname': \"BRadvoc8\"\n\u2502         ]\n\u2502         'provenance': ProvenanceMark(1896ba49) [\n\u2502             {\n\u2502                 'provenanceGenerator': ENCRYPTED [\n\u2502                     'hasSecret': EncryptedKey(Argon2id)\n\u2502                 ]\n\u2502             } [\n\u2502                 'salt': Salt\n\u2502             ]\n\u2502         ]\n\u2502     ]\n\u2502 } [\n\u2502     'signed': Signature(Ed25519)\n\u2502 ]\n</code></pre> <p>The existing metadata of the new XID Document should be identical to the original. The signature was verified then refreshed, while private keys and the provenance mark generator were re-encrypted.</p> <p>Notice that <code>dereferenceVia</code> is a known value (single quotes) from the Known Values registry, and its object is a <code>URI</code> type rather than a plain string. This assertion tells anyone who receives your XID Document: \"To get the current version, fetch from this URL.\" You can add multiple <code>dereferenceVia</code> assertions for redundancy by running the command again with a different URL. For example, you might point to both a GitHub raw URL and a personal domain, so if one source becomes unavailable, verifiers can still fetch your current XID Document from the other.</p>"},{"location":"01_2_Making_a_XID_Verifiable/#step-4-export-public-view","title":"Step 4: Export Public View","text":"<p>You now want to elide the private keys in the XID, to create a view of this edition that is safe for publication. In \u00a71.1, you manually found digests and used <code>envelope elide removing</code> to create a public view. We used that method to show how elision works. However, there's a simpler command that optionally elides the private keys and/or the provenance mark generator: <code>xid export</code>. That's what you'll want to use most of the time (when you're not learning about elision!):</p> <pre><code>PUBLIC_XID=$(envelope xid export --private elide --generator elide \"$XID_WITH_URL\")\n\necho \"\u2705 Exported public version\"\nenvelope format \"$PUBLIC_XID\"\n\n\u2502 \u2705 Exported public version\n\u2502 {\n\u2502     XID(5f1c3d9e) [\n\u2502         'dereferenceVia': URI(https://github.com/BRadvoc8/BRadvoc8/raw/main/xid.txt)\n\u2502         'key': PublicKeys(a9818011, SigningPublicKey(5f1c3d9e, Ed25519PublicKey(b2c16ea3)), EncapsulationPublicKey(96209c0f, X25519PublicKey(96209c0f))) [\n\u2502             'allow': 'All'\n\u2502             'nickname': \"BRadvoc8\"\n\u2502             ELIDED\n\u2502         ]\n\u2502         'provenance': ProvenanceMark(1896ba49) [\n\u2502             ELIDED\n\u2502         ]\n\u2502     ]\n\u2502 } [\n\u2502     'signed': Signature(Ed25519)\n\u2502 ]\n</code></pre> <p>As usual, this removes the content you want to hide, but maintains the hashes, so that the root hash and the signature remain the same.</p>"},{"location":"01_2_Making_a_XID_Verifiable/#step-5-store-your-work","title":"Step 5: Store Your Work","text":"<p>You should now your XIDs to a local file.</p> <p>The following saves both versions of the XID to an <code>envelopes</code> directory that we'll be using in future tutorials. (Amira herself would save the file to that <code>xid-5f1c3d9e</code> directory that she created in the previous section.)</p> <pre><code>mkdir envelopes\necho \"$PUBLIC_XID\" &gt; envelopes/BRadvoc8-xid-public-02.envelope\necho \"\u2705 Public XID saved to envelopes/BRadvoc8-xid-public-02.envelope\"\necho \"$XID_WITH_URL\" &gt; envelopes/BRadvoc8-xid-private-02.envelope\necho \"\u2705 PRIVATE XID saved to envelopes/BRadvoc8-xid-private-02.envelope\n</code></pre>"},{"location":"01_2_Making_a_XID_Verifiable/#step-6-publish-your-xid","title":"Step 6: Publish Your XID","text":"<p>To upload Amira's publix XID to GitHub, create a repository named after the XID (e.g., <code>BRadvoc8/BRadvoc8</code>), add a file named <code>xid.txt</code>, and commit the public XID content. The raw URL follows a predictable pattern, <code>https://github.com/USERNAME/REPO/raw/main/xid.txt</code>, which should be what you recorded in <code>dereferenceVia</code>.</p> <p>Publish literally means \"to make public\", so this is (at last) the publication of your XID. You've locked down the content as shown in this XID as the first edition. If you make changes (as you do starting in chapter 2), at that point you will update the provenance mark before you republish, so that recipients can figure out which edition is the newest.</p> <p>Note that publication doesn't only mean uploading something to a public-facing website. Just emailing a XID to someone is publication, because bits are infinitely copyable: you have no idea how far that single emailed edition will spread.</p>"},{"location":"01_2_Making_a_XID_Verifiable/#bens-story-a-perspective-shift","title":"Ben's Story: A Perspective Shift","text":"<p>Though this is Amira's story, she is trying to join a larger ecosystem of socially conscious programmers and the organizations they support. That's where Ben comes into the story. He runs SisterSpaces, a womens' services nonprofit. Ben received a message from someone claiming to be \"BRadvoc8\":</p> <p>\"Hey Ben, I'm interested in contributing to SisterSpaces. Here's my XID: https://github.com/BRadvoc8/BRadvoc8/raw/main/xid.txt\"</p> <p>Ben doesn't know if this is legitimate. He needs to verify. How does he do so? How does he know he has the current version of Amira's XID, not a stale copy? The verification workflow answers these questions without requiring direct contact with Amira.</p>"},{"location":"01_2_Making_a_XID_Verifiable/#part-ii-verifying-a-xid","title":"Part II: Verifying a XID","text":"<p>Ben has been mailed the XID Document and will test it via a variety of means.</p>"},{"location":"01_2_Making_a_XID_Verifiable/#step-7-fetch-the-xid","title":"Step 7: Fetch the XID","text":"<p>First, Ben fetches the current version of the XID from the <code>dereferenceVia</code> found in the version that he was mailed.</p> <p>He could just input the URL into his browser and then cut and paste the file, but the following instead allows him to retrieve the dereferenced XIDDoc using the command line.</p> <pre><code>RECEIVED_URL=\"https://github.com/BRadvoc8/BRadvoc8/raw/main/xid.txt\"\nCURL_URL=`echo $RECEIVED_URL | sed 's/\\/\\/github.com\\//\\/\\/raw.githubusercontent.com\\//; s/\\/raw\\//\\//'`\nFETCHED_XID=$(curl -H 'Accept: application/vnd.github.v3.raw' $CURL_URL | head -1)\n</code></pre> <p>\u26a0\ufe0f Variable URLs. The <code>dereferenceVia</code> indicated that Ben should retrieve the current XIDDoc from <code>https://github.com/BRadvoc8/BRadvoc8/raw/main/xid.txt</code>. That's a standard GitHub URL for retrieving raw files using a browser. However, it doesn't work with <code>curl</code>, which instead requires an equivalent URL. Replace the <code>github.com</code> site name with <code>raw.githubusercontent.com</code> and drop the <code>/raw/</code> directory to instead retrieve from the command line.</p> <p>You may notice that the <code>FETCHED_URL</code> command only retrieves the first line of the dereference URL, with <code>head -1</code>. That is purposeful for this tutorial, but not general best practice, which would be to instead read the last line of the file, with <code>tail -1</code>. Here's the reason: a file can contain multiple copies of an envelope, each a UR stored on a seperate line. Optimally, these lines will be arranged in chronological order, with the oldest envelope at the top and the newest at the bottom. That's what we're depending on in this tutorial: that the first line of the file will contain the first edition of the envelope, which is the example we're discussing here.</p> <p>We can depend on this ordering in this tutorial because we're preparing the files for use. You can't depend on it when you're dereferencing an arbitrary XID that's been sent to you, but that's fine. XIDs have provenance marks, and the provenance marks will tell you which version is the newest. That's their whole purpose!</p> <p>Ben will of course want to review the XID that he retrieved:</p> <pre><code>envelope format \"$FETCHED_XID\" | head -15\n\n\u2502 \u2705 Fetched XIDDoc from: https://github.com/BRadvoc8/BRadvoc8/raw/main/xid.txt\n\u2502 {\n\u2502     XID(5f1c3d9e) [\n\u2502         'dereferenceVia': URI(https://github.com/BRadvoc8/BRadvoc8/raw/main/xid.txt)\n\u2502         'key': PublicKeys(a9818011, SigningPublicKey(5f1c3d9e, Ed25519PublicKey(b2c16ea3)), EncapsulationPublicKey(96209c0f, X25519PublicKey(96209c0f))) [\n\u2502             'allow': 'All'\n\u2502             'nickname': \"BRadvoc8\"\n\u2502             ELIDED\n\u2502         ]\n\u2502         'provenance': ProvenanceMark(1896ba49) [\n\u2502             ELIDED\n\u2502         ]\n\u2502     ]\n\u2502 } [\n\u2502     'signed': Signature(Ed25519)\n\u2502 ]\n</code></pre> <p>Retrieving a XID in this way is a crucial step because anyone could pass around a XID Document, and more so, anyone could pass around a very old XID Document that has old, inaccurate information. By including a <code>dereferenceVia</code> that refers to a URL that she controls, Amira has ensured that if someone receives her XID Document, they should then go to the URL to pick up a current version, which Ben does.</p> <p>Ben now suspects he has the current version of XID.</p>"},{"location":"01_2_Making_a_XID_Verifiable/#step-8-recheck-the-dereferencevia-url","title":"Step 8: Recheck the dereferenceVia URL","text":"<p>Since Ben has dereferenced the XID that Amira mailed him, to access an up-to-date version of the document, he has the most up-to-date version, right? Not necessarily! It's possible that the URL is no longer Amira's primary publication location, and there's actually a newer version elsewhere! To verify that this isn't the case, Ben should check the <code>dereferenceVia</code> one more time, looking at the new document that he downloaded. He does this by extracting the <code>dereferenceVia</code> from this fetched and unwrapped XID, and comparing it to the URL that he used to lookup the XID.</p> <pre><code>UNWRAPPED=$(envelope extract wrapped \"$FETCHED_XID\")\nDEREFERENCE_ASSERTION=$(envelope assertion find predicate known dereferenceVia \"$UNWRAPPED\")\nDEREFERENCE_URL=$(envelope extract object \"$DEREFERENCE_ASSERTION\" | envelope format | sed 's/.*URI(\\(.*\\))/\\1/')\n\necho \"URL Ben fetched from:     $RECEIVED_URL\"\necho \"dereferenceVia in XID:    $DEREFERENCE_URL\"\n\nif [ \"$RECEIVED_URL\" = \"$DEREFERENCE_URL\" ]; then\n    echo \"\u2705 URLs match - XID claims this is its canonical location\"\nelse\n    echo \"\u26a0\ufe0f  URLs don't match - XID may have been copied from elsewhere\"\nfi\n\n\u2502 URL Ben fetched from:     https://github.com/BRadvoc8/BRadvoc8/raw/main/xid.txt\n\u2502 dereferenceVia in XID:    URI(https://github.com/BRadvoc8/BRadvoc8/raw/main/xid.txt)\n\u2502 \u2705 URLs match - XID claims this is its canonical location\n</code></pre> <p>If the URLs match, Ben is even more certain that he has the most up-to-date XID. If they don't, then Ben should look at the <code>dereferenceVia</code> in the new XID that he retrieved and follow it to the URL that it points to, repeating steps 6-7 until he actually gets a XID that matches its own <code>dereferenceVia</code>. (Usually these additional steps wont' be required at all, but they should definitely be part of a verifier checklist.)</p> <p>Barring some weird issue like a circular set of dereferences, or a dead URL, Ben should now have a XIDDoc that is the newest version. But can he trust it?</p>"},{"location":"01_2_Making_a_XID_Verifiable/#step-9-verify-the-signature-provenance","title":"Step 9: Verify the Signature &amp; Provenance","text":"<p>Ben will now repeat the steps from \u00a71.1, verifying the signature and the provenance mark.</p> <pre><code>UNWRAPPED=$(envelope extract wrapped \"$FETCHED_XID\")\nKEY_ASSERTION=$(envelope assertion find predicate known key \"$UNWRAPPED\")\nKEY_OBJECT=$(envelope extract object \"$KEY_ASSERTION\")\nPUBLIC_KEYS=$(envelope extract ur \"$KEY_OBJECT\")\n\nif envelope verify -v \"$PUBLIC_KEYS\" \"$FETCHED_XID\" &gt;/dev/null 2&gt;&amp;1; then\n    echo \"\u2705 Signature verified - XID is self-consistent\"\nelse\n    echo \"\u274c Signature FAILED - XID may be tampered\\!\"\n    exit 1\nfi\n\nPROVENANCE_MARK=$(envelope xid provenance get \"$FETCHED_XID\")\n\necho \"Checking provenance mark...\"\nprovenance validate \"$PROVENANCE_MARK\" &amp;&amp; echo \"\u2705 Provenance chain intact\"\n\n\u2502 \u2705 Signature verified - XID is self-consistent\n| \u2705 Provenance chain intact\n</code></pre> <p>He could also examine details of the provenance mark with <code>provenance validate --format json-pretty \"$PROVENANCE_MARK\"</code>, but since this is Amira's first edition, it'll look the same as it did in 1.1 The more interesting test would come if Ben had multiple, different copies of the XID and needed to determine which was stale and which fresh, but that's a topic for chapter 2</p>"},{"location":"01_2_Making_a_XID_Verifiable/#what-if-the-xid-was-tampered-with","title":"What If the XID Was Tampered with?","text":"<p>What happens if an attacker intercepts and modifies the XID before Ben receives it? The following change simulates tampering by removing the last character from the $FETCHED_XID variable. A more sophisticated attacker would use a UR playground to change the content of the envelope, but the results would be the same.</p> <pre><code>TAMPERED_XID=${FETCHED_XID::-1}\n</code></pre> <p>In either case, the verification would fail because any modification, even a single character, invalidates the signature: the cryptographic hash of the tampered document no longer matches what was signed.</p> <pre><code>if envelope verify -v \"$PUBLIC_KEYS\" \"$TAMPERED_XID\" &gt;/dev/null 2&gt;&amp;1; then\n    echo \"\u2705 Signature verified\"\nelse\n    echo \"\u274c Signature FAILED - tampering detected\\!\"\nfi\n\n\u2502 \u274c Signature FAILED - tampering detected!\n</code></pre> <p>This is why signature verification is an important check: it catches any tampering that occurred after Amira signed the document.</p> <p>\ud83e\udde0 Learn More. The Signing and Verification concept doc explains how envelope signatures work and why elision preserves signature validity.</p>"},{"location":"01_2_Making_a_XID_Verifiable/#step-10-assess-your-level-of-trust","title":"Step 10: Assess Your Level of Trust","text":"<p>Although Ben has run a few tests, he still has limited information about the BRadvoc8 identity. So what can he trust?</p> <p>Three things have been cryptographically verified:</p> <ul> <li>The XID was signed by someone holding the private signing key referenced in the XID.</li> <li>This means that the XID is self-consistent.</li> <li>The XID hasn't been tampered with since it was signed.</li> <li>This means that the XID is what the signer signed-off on (but not that the content is necessarily true).</li> <li>The provenance mark verifies, without any errors highlighting gaps.</li> <li>This means that the provenance chain is complete; to be precise, detailed data shows that the XID is a first edition.</li> </ul> <p>One thing is very likely verified:</p> <ul> <li>The XID is the most up-to-date edition of the identifier.</li> <li>There still is the possibility that Amira made a newer XID without updating the <code>dereferenceVia</code> site, but Ben did enough due dilligence to demonstrate that it's unlikely that he has an out-of-date version of the XID.</li> </ul> <p>But a few other things are just assumed, without proof:</p> <ul> <li>Amira has control of the GitHub account.</li> <li>Though Amira's XID being on the GitHub account is suggestive, more would need to be done to prove she owned it.</li> <li>Amira is who she says she is.</li> <li>A pseudonymous identity can never provide absolute proof of who someone is, but attestations and cross-verifications can offer increasingly strong evidence.</li> </ul> <p>Future tutorials will concentrate on showing how a XID can better support these assumptions.</p> <p>\ud83e\udde0 Learn More. The Progressive Trust concept doc explores the full trust hierarchy and how verification layers combine.</p> What Ben Can Verify What Remains Unproven \u2705 Signature is valid \u2753 XID owner controls GitHub account \u2705 derferenceVia matched fetch URL \u2753 Whether BRadvoc8 has skills \u2705 Valid genesis provenance mark \u2753 Who BRadvoc8 is"},{"location":"01_2_Making_a_XID_Verifiable/#summary-a-stable-id","title":"Summary: A Stable ID","text":"<p>The BRadvoc8 identify now has a stable publication URL, provenance tracking for edition verification, and cryptographic integrity through self-signing. The freshness problem is also solved: Ben can fetch current versions without waiting for Amira to send updates, verify that he has the latest copy, and detect if someone gives him stale data.</p>"},{"location":"01_2_Making_a_XID_Verifiable/#exercises","title":"Exercises","text":"<p>Try these to solidify your understanding:</p> <p>Publishing exercises (Amira's perspective):</p> <ul> <li>Publish your XID for real: create a GitHub repository, add the URL with <code>xid resolution add</code>, export the public version, and commit it.</li> <li>Add multiple <code>dereferenceVia</code> assertions pointing to different mirrors (e.g., GitHub and a personal domain).</li> </ul> <p>Verification exercises (Ben's perspective):</p> <ul> <li>Download someone else's published XIDDoc and run the full verification workflow: signature, dereferenceVia match, and provenance check.</li> <li>Deliberately tamper with a copy (change a character) and verify that signature verification fails.</li> </ul>"},{"location":"01_2_Making_a_XID_Verifiable/#whats-next","title":"What's Next","text":"<p>Ben's open question about skills is the biggest issue with Amira's BRadvoc8 at this point. Making claims, and figuring out how to hide sensitive ones, will be the topics of Chapter 2.</p>"},{"location":"01_2_Making_a_XID_Verifiable/#example-script","title":"Example Script","text":"<p>A complete working script implementing this tutorial is available at <code>../tests/02-making-xid-verifiable-TEST.sh</code>. Run it to see all steps in action:</p> <pre><code>bash tests/02-making-xid-verifiable-TEST.sh\n</code></pre> <p>This script tests both Amira's publication workflow and Ben's verification workflow.</p>"},{"location":"01_2_Making_a_XID_Verifiable/#appendix-i-key-terminology","title":"Appendix I: Key Terminology","text":"<p><code>dereferenceVia</code> - A known predicate indicating where the canonical version of this XID can be fetched. Uses <code>URI</code> type for the object.</p> <p>Freshness - The property of having the most current version of an XID, verified through publication URLs and provenance marks.</p> <p>Provenance Chain - The sequence of provenance marks showing the history of XID updates. Each mark links to the previous.</p> <p>Self-Consistency - An XID is self-consistent when its signature verifies against its own embedded public key. This proves the document wasn't tampered with after signing, but not that the claims inside are true.</p> <p>Sequence Number - The position in the provenance chain (0 = genesis, 1 = first update, etc.).</p>"},{"location":"02_0_Claims/","title":"Chapter Two: Making Claims (And Protecting Them)","text":"<p>A XID is just an identifier: a pseudonymous label that allows for consistent reference over time. Keys and a provenance mark support it, but they're ultimately infrastructure: the keys control the identifier, and the provenenance mark supports updates.</p> <p>For an identifier to truly become an identity requires more: it requires a rich collection of data that define and describe the real person behind the identifier (or at least the persona that they embody when they interact using the identifier).</p> <p>A variety of content will be added to an identifier over this course, and the first of those will be self-attestations: claims made by the owner of the identifier themself. However, these first, simple claims also offer the first danger of a breach in the cloak of pseudonymity that a XID offers, so the addition of claims must go hand in hand with the discussion of how to properly protect them.</p>"},{"location":"02_0_Claims/#major-objectives-for-this-chapter","title":"Major Objectives for this Chapter","text":"<p>After working through this chapter, a developer will be able to:</p> <ul> <li>Register additional keys in their XID.</li> <li>Create attestations that are publicly verifiable.</li> <li>Advance provenance marks.</li> <li>Commit to claims.</li> <li>Encrypt claims.</li> </ul> <p>Supporting objectives include the ability to:</p> <ul> <li>Understand the fair witness methodology for making credible claims.</li> <li>Recognize correlation risks.</li> <li>Know the difference between a variety of types of attestations.</li> <li>Choose between a variety of methods for handling sensitive information</li> </ul>"},{"location":"02_0_Claims/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Section One: Creating Self Attestation</li> <li>Section Two: Managing Sensitive Claims with Elision</li> <li>Section Three: Managing Sensitive Claims with Encryption</li> </ul>"},{"location":"02_1_Creating_Self_Attestations/","title":"2.1: Creating Self Attestations","text":"<p>This section demonstrates how to build credibility through specific, factual claims that invite verification rather than demand belief.</p> <p>\ud83e\udde0 Related Concepts. After completing this tutorial, explore Progressive Trust and Self-Attestation to deepen your understanding.</p>"},{"location":"02_1_Creating_Self_Attestations/#objectives-for-this-section","title":"Objectives for this Section","text":"<p>After working through this section, a developer will be able to:</p> <ul> <li>Register attestation keys in a XID for signature verification</li> <li>Create attestations that are publicly verifiable.</li> <li>Advance a provenance mark.</li> </ul> <p>Supporting objectives include the ability to:</p> <ul> <li>Understand how to use fair witness methodology to make credible claims</li> <li>Know the difference between detached and embedded attestations.</li> </ul>"},{"location":"02_1_Creating_Self_Attestations/#amiras-story-claims-without-proof","title":"Amira's Story: Claims Without Proof","text":"<p>Following Chapter 1, Ben has a verified copy of BRadvoc8's XID. But it's just a collection of keys attached to a nickname. Can BRadvoc8 write good code, understand security, and deliver quality work? These are the questions that Ben needs answered before he decides to bring BRadvoc8 into the SisterSpace project.</p> <p>To reveal more about her skill set, Amira must create attestations about them. Since Amira is bootstrapping the BRadvoc8 identity on her own, they need to be self-attestations: things that she says about herself (or rather, about her identity) that reveal her capabilities. The problem is that a vague claim like \"Security expert with 8 years experience\" is worthless. Anyone can type that.</p> <p>\ud83d\udcd6 What is a self attestation?: As the name suggestion, a self attestation is a claim that you make about yourself. It's contrasted with an endorsement, where someone else vouches for you. Self-attestations are starting points; endorsements carry more weight because they come from independent parties.</p> <p>Amira needs a different approach: specific claims that point to verifiable evidence.</p>"},{"location":"02_1_Creating_Self_Attestations/#the-power-of-fair-witness-attestations","title":"The Power of Fair Witness Attestations","text":"<p>Not all attestations are created equal. Some are vague and hard to pin down, while others are so specific that they can be proven with appropriate references. Compare these two attestations:</p> Claim Quality Support \"I'm good at security\" Weak Opinion, nothing to check \"I contributed to Galaxy Project (PR #12847)\" Strong Verifiable on GitHub <p>The strong claim invites validation rather than demanding belief. For pseudonymous contributors who can't flash a diploma, evidence-backed attestations ARE your credentials.  When you are making self-attestations, it is therefore best to both create attestations that are verifiable and then provide the methodology for verifying.</p> <p>\"Fair witness claims\" are a particularly strong type of attestation. The person making the attestation does their best to report without interpretation, assumption, or bias (as best they can!).</p> <p>\ud83d\udcd6 What is the Fair Witness Methodology?: The Fair Witness methodology is derived from Robert E. Heinlein's Stranger in a Strange Land (1961). A Fair Witness makes a claim of what they directly observed, avoiding interpretation, assumption, or (as much as possible) bias. If it's meaningful, a fair witness claim also should include context describing the methodology of the observation, its limitations, and any bias built into.</p> <p>Saying someone was good at security would be an interpretation, so that would fail the fair witness test, but instead reporting a contribution is a simple statement of fact, as long as you don't adorn it by saying something like, \"I made a crucial contribution to the Galaxy Project.\"</p> <p>\ud83d\udd25 What is the Power of Fair Witness Attestations? Fair witness attestations do their best to report without bias. This makes them more verifiable, and verifiability is what's important in the world of pseudonymous claims.</p>"},{"location":"02_1_Creating_Self_Attestations/#part-i-adding-an-attestation-key","title":"Part I: Adding an Attestation Key","text":"<p>Amira contributed to Galaxy Project, an open source bioinformatics platform. Her pull request added mass spectrometry visualization features. This is the kind of specific, verifiable claim that builds real credibility. You're going to build an attestation about that claim, but first you need to create a secure way to make attestations.</p>"},{"location":"02_1_Creating_Self_Attestations/#step-0-verify-dependencies-reload-xid","title":"Step 0: Verify Dependencies &amp; Reload XID","text":"<p>Before you get started, ensure you have the required tools installed:</p> <pre><code>envelope --version\nprovenance --version\n\n\u2502 bc-envelope-cli 0.34.1\n\u2502 provenance-mark-cli 0.7.0\n</code></pre> <p>If not installed, see \u00a71.1 for installation instructions.</p> <p>You'll also want to reload your XID. The following assumes use of the <code>envelopes</code> directory that was described in the last tutorial.</p> <pre><code>XID=$(cat envelopes/BRadvoc8-xid-private-02.envelope)\nXID_ID=$(envelope xid id $XID)\n</code></pre>"},{"location":"02_1_Creating_Self_Attestations/#step-1-create-an-attestation-key","title":"Step 1: Create an Attestation Key","text":"<p>Every attestation, even a self-attestation should be signed. Viewers have to know who is behind a claim and that the claim hasn't been changed since that person agreed to it. You could sign attestations with the signing key of your XID. However, that's your XID inception key, and it's powerful: it can modify your identity. Using it for routine signing increases exposure risk. For that reason, you want to create new attestation keys that can be rotated or revoked without affecting your core identity.</p> <pre><code>ATTESTATION_PRVKEYS=$(envelope generate prvkeys --signing ed25519)\nATTESTATION_PUBKEYS=$(envelope generate pubkeys \"$ATTESTATION_PRVKEYS\")\n</code></pre> <p>\ud83d\udcd6 What are Attestation Keys?: Attestation keys are   dedicated signing key for making attestations.</p>"},{"location":"02_1_Creating_Self_Attestations/#step-2-register-attestation-key-in-xid","title":"Step 2: Register Attestation Key in XID","text":"<p>For Ben to verify attestations came from BRadvoc8, the attestation public key must be in the XID. You also should embed the private key (encrypted) so that Amira can sign attestations without managing separate key files. This is done with the <code>xid key add</code> command, which is very similar yo the <code>xid resolution add</code> function that you used in the last tutorial.</p> <pre><code>PASSWORD=\"your-password-from-previous-tutorials\"\nUPDATED_XID=$(envelope xid key add \\\n    --nickname \"attestation-key\" \\\n    --allow sign \\\n    --password \"$PASSWORD\" \\\n    --private encrypt \\\n    --encrypt-password \"$PASSWORD\" \\\n    \"$ATTESTATION_PRVKEYS\" \\\n    \"$XID\")\n\necho \"\u2705 Added attestation key to XID\"\n</code></pre> <p>The <code>envelope-cli</code> programs derives the public key from the private key automatically. With the <code>--private encrypt</code>, <code>--password</code>, and <code>--encrypt-password</code> commands, the private XID is first decrypted, then re-encrypted. You also add a new <code>nickname</code> to clarify what the key is for, and tthen here's one new argument:</p> <ol> <li><code>--allow sign</code> is a permission statement indicates this key can only sign, it cannot modify the XID itself. (That requires the inception key.)</li> </ol> <p>\u26a0\ufe0f XID Functions Only! If you're familiar with Gordian Envelope, you'll know that you can freely add assertions to an envelope. Though XID is built on envelope, it's intended to be a much more structured format, with all content always in carefully structured places such as <code>derferenceVia</code>, <code>key</code>, <code>provenance</code>, and other subjects that you'll meet in future tutorials. You should always expect to use <code>envelope xid</code> commands when working with the core XID structure (though you may place less structured content under certain key words, such as in the <code>edge</code> that we'll meet in the chapter 3).</p>"},{"location":"02_1_Creating_Self_Attestations/#step-3-advance-your-provenance-mark","title":"Step 3: Advance Your Provenance Mark","text":"<p>You're going to need to publish this XID so that Ben can check Amira's self-attestation against her new signature. Whenever you publish a new edition of a XID (meaning that you've changed the underlying content, not just changing the view by eliding existing data differently), you should also advance the provenance mark. This will allow viewers who have multiple copies of a XID to determine which one is newest.</p> <p>Advancing the provenance mark is done with the simple <code>provenance next</code> command, which as usual must decrypt and reencrypt your content:</p> <pre><code>UPDATED_XID=$(envelope xid provenance next \\\n    --password \"$PASSWORD\" \\\n    --private encrypt \\\n    --generator encrypt \\\n    --encrypt-password \"$PASSWORD\" \\\n    \"$UPDATED_XID\")\necho \"\u2705 Provenance advanced\"\n\n| \u2705 Provenance advanced\n</code></pre> <p>You can see what your XID looks like after all that work:</p> <pre><code>envelope format $UPDATED_XID\n\n| XID(5f1c3d9e) [\n|     'dereferenceVia': URI(https://github.com/BRadvoc8/BRadvoc8/raw/main/xid.txt)\n|     'key': PublicKeys(21914050, SigningPublicKey(04c9adb6, Ed25519PublicKey(09f7c306)), EncapsulationPublicKey(1b076286, X25519PublicKey(1b076286))) [\n|         {\n|             'privateKey': ENCRYPTED [\n|                 'hasSecret': EncryptedKey(Argon2id)\n|             ]\n|         } [\n|             'salt': Salt\n|         ]\n|         'allow': 'Sign'\n|         'nickname': \"attestation-key\"\n|     ]\n|     'key': PublicKeys(a9818011, SigningPublicKey(5f1c3d9e, Ed25519PublicKey(b2c16ea3)), EncapsulationPublicKey(96209c0f, X25519PublicKey(96209c0f))) [\n|         {\n|             'privateKey': ENCRYPTED [\n|                 'hasSecret': EncryptedKey(Argon2id)\n|             ]\n|         } [\n|             'salt': Salt\n|         ]\n|         'allow': 'All'\n|         'nickname': \"BRadvoc8\"\n|     ]\n|     'provenance': ProvenanceMark(f6baa8c6) [\n|         {\n|             'provenanceGenerator': ENCRYPTED [\n|                 'hasSecret': EncryptedKey(Argon2id)\n|             ]\n|         } [\n|             'salt': Salt\n|         ]\n|     ]\n| ]\n</code></pre>"},{"location":"02_1_Creating_Self_Attestations/#step-4-export-save-your-xid","title":"Step 4: Export &amp; Save Your XID","text":"<p>Afterward, you should follow the usual procedure to create a public version of the XID and store it.</p> <pre><code>UPDATED_PUBLIC_XID=$(envelope xid export --private elide --generator elide \"$UPDATED_XID\")\n\necho \"\u2705 Public XID ready for publication\"\n\n\u2502 \u2705 Public XID ready for publication\n</code></pre> <p>Amira would publish this updated XID at her <code>dereferenceVia</code> URL so Ben can fetch it and verify her attestation signatures.</p> <p>You'll store it alongside your previous iteration (with the genesis provenance mark):</p> <pre><code>echo \"$UPDATED_PUBLIC_XID\" &gt; envelopes/BRadvoc8-xid-public-03.envelope\necho \"$UPDATED_XID\" &gt; envelopes/BRadvoc8-xid-private-03.envelope\n</code></pre> <p>You should also store standalone copies of your new keys to make it easier to access them in the future:</p> <pre><code>echo $ATTESTATION_PRVKEYS &gt; envelopes/attestation-private-03.ur\necho $ATTESTATION_PUBKEYS &gt; envelopes/attestation-public-03.ur\n</code></pre>"},{"location":"02_1_Creating_Self_Attestations/#step-5-review-your-work","title":"Step 5: Review Your Work","text":"<p>You now have multiple keys and multiple XIDs for Amira. Here's a look at each of them.</p>"},{"location":"02_1_Creating_Self_Attestations/#key-type-comparison","title":"Key Type Comparison","text":"<p>It is a best practice to have different keys for different purposes. This improves privacy and decreases the repercussions of key loss or compromise. The traditional problem with this approach has been figuring out how to handle a \"bag of keys.\" XIDs offer the answer: they can be used to manage a whole set of keys, and the keys can be encrypted with a password for protection on your own storage and elided for near-total protection when a XID is shared.</p> <p>So far, Amira has two keys:</p> Key Type Purpose Verified Against Added In \ud83d\udc64 XID inception key Signs XID document updates XID itself \u00a71.1 \ud83d\udd11 Attestation key Signs attestations XID key list \u00a72.1"},{"location":"02_1_Creating_Self_Attestations/#xid-version-comparison","title":"XID Version Comparison","text":"<p>Here's a look at our two XID versions created to date:</p> XID Version New Content Created In seq 0 \ud83d\udc64 Identity \u00a71.1+\u00a71.2 seq 1 \ud83d\udd11 Attestation Key \u00a72.1"},{"location":"02_1_Creating_Self_Attestations/#part-ii-creating-a-detached-attestation","title":"Part II: Creating a Detached Attestation","text":"<p>With an attestation key in hand, and linked to Amira's XID, you're now ready to create an attestation for Amira. But the question is whether to create an embedded attestation (which would be placed directly in Amira's XID) or a detached attestation (which would be available as a separate Gordian Envelope but linked to Amira's XID by the use of the attestation signature key). </p> <ul> <li>It's best to embed attestations if they're relatively permanent, widely applicable, and core to the definition of the identity.</li> <li>It's best to create detached attestations if they're ephemeral, if they're only relevant to specific people and if they're not core to an identity.</li> </ul> <p>This isn't a question of privacy: you can always choose to elide and encrypt attestations that you don't want to receive wide attention, even if they're in your XID. (In fact that's the topic of the next two tutorials.) It's instead a question of keeping the XID lean enough that someone can reasonably look over it without being lost in irrelevent details.</p> <p>\ud83d\udcd6 What is a Detached Attestation?: When an attestation is detached, it appears as a signed statement that exists as a separate envelope, referencing your XID but not embedded in your XIDDoc.</p> <p>In this case, a single PR is a pretty small detail, and not necessarily something that Amira will be talking about in a year or two when she (hopefully) has major design work on SisterSpaces to point to. So you'll create it as a detached attestation.</p>"},{"location":"02_1_Creating_Self_Attestations/#step-6-create-the-claim","title":"Step 6: Create the Claim","text":"<p>Start with the claim itself as the envelope subject. Freeform attestation of this type are created with the standard <code>envelope</code> commands rather than the more constrained <code>envelope xid</code> commands. That's because they're either going to be separate from a XID (as a detached attestation) or they're going to be attached to a XID at a specific, defined point, such as <code>attachment</code> or <code>edge</code> (which we'll meet in chapter 3).</p> <pre><code>CLAIM=$(envelope subject type string \\\n  \"Contributed mass spec visualization code to galaxyproject/galaxy (PR #12847, merged 2024)\")\n\nenvelope format \"$CLAIM\"\n\n\u2502 \"Contributed mass spec visualization code to galaxyproject/galaxy (PR #12847, merged 2024)\"\n</code></pre> <p>This is just a string. It's not signed, attributed, or structured. Anyone could create this string.</p>"},{"location":"02_1_Creating_Self_Attestations/#step-7-add-attestation-metadata","title":"Step 7: Add Attestation Metadata","text":"<p>Now add metadata that structures this as a formal attestation.</p> <pre><code>ATTESTATION=$(envelope assertion add pred-obj known isA known 'attestation' \"$CLAIM\")\nATTESTATION=$(envelope assertion add pred-obj known source ur $XID_ID \"$ATTESTATION\")\nATTESTATION=$(envelope assertion add pred-obj known target ur $XID_ID \"$ATTESTATION\")\nATTESTATION=$(envelope assertion add pred-obj known 'verifiableAt' uri \"https://github.com/galaxyproject/galaxy/pull/12847\" \"$ATTESTATION\")\nATTESTATION=$(envelope assertion add pred-obj known 'date' string `date -Iminutes` \"$ATTESTATION\")\nenvelope format \"$ATTESTATION\"\n\n\"Contributed mass spec visualization code to galaxyproject/galaxy (PR #12847, merged 2024)\" [\n    'isA': 'attestation'\n    'date': \"2025-10-18T19:27-10:00\"\n    'source': XID(5f1c3d9e)\n    'target': XID(5f1c3d9e)\n    'verifiableAt': URI(https://github.com/galaxyproject/galaxy/pull/12847)\n]\n</code></pre> <p>Each assertion within the claim is a standardized known value that reveals a specific piece of metadata:</p> Assertion Known Value Value Purpose 1 <code>'isA'</code> <code>'attestation'</code> Declares this is an attestation 2 <code>'date'</code> ISO 8601 Claims when attestation was constructed 3 <code>'source'</code> XID ID Says who is making the attestation 4 <code>'target'</code> XID ID Says who the attestation is about 5 <code>\"verifiableAt\"</code> URI Points to evidence for independent verification <p>\u26a0\ufe0f Dates are Unreliable!  The date is actually another unverifiable claim: it could be set to whatever the attestation creator wants to. Nonetheless, it has use because a good faith creator will date claims correctly, making it see easy to which claims are newer in case of a superseding claim being issued.</p>"},{"location":"02_1_Creating_Self_Attestations/#step-8-sign-the-attestation","title":"Step 8: Sign the Attestation","text":"<p>You're now ready to wrap the attestation and sign it with the private key that you created specifically for this purpose. The signature proves that the signer made this claim:</p> <pre><code>ATTESTATION_WRAPPED=$(envelope subject type wrapped $ATTESTATION)\nATTESTATION_SIGNED=$(envelope sign --signer \"$ATTESTATION_PRVKEYS\" \"$ATTESTATION_WRAPPED\")\n\nenvelope format \"$ATTESTATION_SIGNED\"\n\n| {\n|     \"Contributed mass spec visualization code to galaxyproject/galaxy (PR #12847, merged 2024)\" [\n|         'isA': 'attestation'\n|         'date': \"2025-10-18T19:27-10:00\"\n|         'source': XID(5f1c3d9e)\n|         'target': XID(5f1c3d9e)\n|         'verifiableAt': URI(https://github.com/galaxyproject/galaxy/pull/12847)\n|     ]\n| } [\n|     'signed': Signature(Ed25519)\n| ]\n</code></pre> <p>The signature covers the entire attestation. If anyone modifies any part (the claim, the source, the target, the date, the verification location), the signature becomes invalid.</p>"},{"location":"02_1_Creating_Self_Attestations/#part-iii-verifying-a-new-claim","title":"Part III: Verifying a New Claim","text":"<p>Switching once more to Ben's perspective, the updated XID and the claim now need to be verified</p>"},{"location":"02_1_Creating_Self_Attestations/#step-9-check-the-new-xid","title":"Step 9: Check the New XID","text":"<p>Amira might send Ben her updated XID, leading him to dereference it, or she might cut out the middle man by just telling him she has a new version of her XID online with a claim. She also sends him the attestation.</p> <pre><code>BEN_FETCHED_XID=\"$UPDATED_PUBLIC_XID\" # Actually, he downloads it\n</code></pre> <p>At this point, Ben would check the XID to make sure that it has continuity with the previous version. One way to do so is to check that it's still signed with the same private key as before. Ben uses the same process as in th eprevious chapter to do so and know that that BRadvoc8 has likely created the new XID.</p>"},{"location":"02_1_Creating_Self_Attestations/#step-10-check-the-new-provenance-mark","title":"Step 10: Check the New Provenance Mark","text":"<p>Ben can also look at the updated provenance mark, and this is where things get more interesting:</p> <pre><code>UPDATED_PROV_MARK=$(envelope xid provenance get \"$BEN_FETCHED_XID\")\nprovenance validate --format json-compact \"$UPDATED_PROV_MARK\" 2&gt;&amp;1 | grep -o '\"end_seq\":[0-9]*'\n\n\u2502 \"end_seq\":1\n</code></pre> <p>The XID's provenance mark is now at sequence 1: genesis (seq 0) created the identity and this update (seq 1) added the attestation key.</p> <p>If Ben still has a copy of the original XID around, he can comparethat one's provenance mark:</p> <pre><code>PROV_MARK=$(envelope xid provenance get \"$XID\")\nprovenance validate --format json-compact \"$PROV_MARK\" 2&gt;&amp;1 | grep -o '\"end_seq\":[0-9]*'\n\n| \"end_seq\":0\n</code></pre> <p>He now knows that the XID he most recently received has a higher sequence number than the previous one, which means that it's newer ... as long as their part of the same provenance mark chain.</p> <p>He can prove that last fact by validating both provenance marks together:</p> <pre><code>provenance validate $PROV_MARK $UPDATED_PROV_MARK\n\n\u2502 \u2705 (silent success - part of the same chain)\n</code></pre> <p>He now knows that they're both part of the same chain and there are no other problems.</p>"},{"location":"02_1_Creating_Self_Attestations/#step-11-check-the-claims-signature","title":"Step 11: Check the Claim's Signature","text":"<p>The XID has been validated but what about the claim? Is it really related to Amira's XID? To determine that, Ben first needs to extract all of the pubkeys from BRadvoc8's XID using <code>xid key all</code>, as he doesn't know which was used for signing:</p> <pre><code>read -d '' -r -a PUBKEY &lt;&lt;&lt; $(envelope xid key all \"$BEN_FETCHED_XID\")\n</code></pre> <p>This is somewhat arcane BASH-ing. If he preferred, Ben could just output <code>envelope xid key all</code> to his screen, and then copy each one to a variable by hand and check each of those by hand  with <code>envelope verify -v</code>.</p> <p>But by having them in an array, Ben can do a quick check to see if any of the signatures verified (tossing out failures, because they're totally OK: only one key needs to be matched):</p> <pre><code>for i in \"${PUBKEY[@]}\"\n  do\n    if envelope verify -v $i $ATTESTATION_SIGNED &gt;/dev/null 2&gt;&amp;1; then\n      echo \"\u2705 One of the signatures verified! \"\n      echo $i\n    fi\ndone\n</code></pre> <p>The result:</p> <pre><code>| \u2705 One of the signatures verified! \n| ur:envelope/lrtpsotansgylftanshflfaohdcxuydpdtjntyecmogmvdeydyksttleeeeerdptrtjyzcmoaoimtokigreonltshnoltansgrhdcxjzptmodkhtsgzmkbdpdweesngdeeoxktwncfehmndegtamswplclpfbsptroaagaoycscstpsojlhsjyjyihjkjyhsjyinjljtdpjeihkkoycsfncsfdhdcxwewljefsbzmklsvasbgakpbdbkcfmohhynjzkksrtdhhsktkfepfbezmhlbsjlntessabskb\n</code></pre> <p>Now Ben knows that the claim was signed by BRadvoc8's XID. But, this says nothing about whether the claim is accurate. Anyone can claim \"I contributed to Galaxy Project.\" The signature proves you MADE the claim, not that you made the contribution. This distinction matters. Self attestations are starting points for building trust, not proof of competence. The <code>verifiableAt</code> field points to evidence that verifiers can check independently.</p>"},{"location":"02_1_Creating_Self_Attestations/#step-12-check-the-claim","title":"Step 12: Check the Claim","text":"<p>Ben follows the <code>verifiableAt</code> URL to GitHub and verifies that PR #12847 exists, was merged, and adds mass spec visualization. He also sees that it was created by a GitHub account with the name of \"BRadvoc8\". This is all very suggestive and provides some verification for Amira's claim.</p> <p>However, there is still a gap: Ben can't prove that BRadvoc8, the controller of the XID, is the same person as BRadvoc8, the owner of the GitHub account. If the XID could show proof of control of the GitHub again, that would almost entirely verify the claim. We'll get back to that in chapter 3. For now, Ben has a medium level of trust. If this claim were combined with other attestations and eventual peer endorsements, a picture of credibility could build over time.</p> <p>:brain: Learn more: The Progressive Trust concept doc explains how self-attestations combine with cross-verification and peer endorsements to build meaningful trust over time.</p>"},{"location":"02_1_Creating_Self_Attestations/#step-13-assess-your-level-of-trust","title":"Step 13: Assess Your Level of Trust","text":"<p>At this point, Ben can once more lay out what he knows:</p> What Ben Can Verify What Remains Unproven \u2705 BRadvoc8 made this claim\u2705 Claim wasn't modified (signature valid) \u2753 Claim is actually true \u2705 Attestation date recorded \u2753 Date is actually corect \u2705 Evidence URL exists \u2753 BRadvoc8 is PR author&lt;br\u2753 Quality of the contribution \u2705 BRadvoc8 is more detailed \u2753 Who BRadvoc8 is"},{"location":"02_1_Creating_Self_Attestations/#part-v-managing-the-attestation-lifecycle","title":"Part V: Managing the Attestation Lifecycle","text":"<p>Attestations aren't permanent. Claims become stale, projects end, and ultimately skills evolve. Amira's Galaxy Project contribution from 2024 is factual forever, but if she added more PRs over time, she might want that to be recorded in her attestation. However, you can never actually change an existing attestation: once a claim is signed, it's immutable. Instead, you have three possibilities: you can create new attestations, supersede attestations, or retract attestations.</p> Situation Approach Claim is still true Create new attestation on related topic Claim is outdated Create superseding attestation Claim was wrong Create retraction attestation <p>Creating a totally new attestation follows the same procedure as above. Our suggested best practices for superseding and revoking involve creating totally new attestations that clearly denote their relationship to the previous ones.</p>"},{"location":"02_1_Creating_Self_Attestations/#step-14-supersede-an-attestation","title":"Step 14: Supersede an Attestation","text":"<p>Two years later, Amira's Galaxy Project work has expanded. This means the old claim is outdated, requiring a new one that supersedes it.</p> <pre><code>S_ATTESTATION=$(envelope subject type string \\\n  \"Contributed mass spec visualization and data pipeline code to galaxyproject/galaxy (PRs #12847, #14201, #15892, 2024-2026)\")\nS_ATTESTATION=$(envelope assertion add pred-obj known isA known 'attestation' \"$S_ATTESTATION\")\nS_ATTESTATION=$(envelope assertion add pred-obj known source ur $XID_ID \"$S_ATTESTATION\")\nS_ATTESTATION=$(envelope assertion add pred-obj known target ur $XID_ID \"$S_ATTESTATION\")\nS_ATTESTATION=$(envelope assertion add pred-obj known 'verifiableAt' uri \"https://github.com/galaxyproject/galaxy/pulls?q=author:BRadvoc8\" \"$S_ATTESTATION\")\nS_ATTESTATION=$(envelope assertion add pred-obj known 'date' string `date -Iminutes` \"$S_ATTESTATION\")\n</code></pre> <p>But you don't want to just create a new attestation that expands on the first, you want to also reference the original attestation being superseded, which can be done by referencing its digest (hash):</p> <pre><code>ORIGINAL_DIGEST=$(envelope digest \"$ATTESTATION_SIGNED\")\nS_ATTESTATION=$(envelope assertion add pred-obj string \"supersedes\" digest \"$ORIGINAL_DIGEST\" \"$S_ATTESTATION\")\n</code></pre> <p>This ensures that viewers can understand the relationship between the two attestation.</p> <p>You would now wrap &amp; sign the attestation as usual:</p> <pre><code>S_WRAPPED_ATTESTATION=$(envelope subject type wrapped $S_ATTESTATION)\nS_SIGNED_ATTESTATION=$(envelope sign --signer \"$ATTESTATION_PRVKEYS\" \"$S_WRAPPED_ATTESTATION\")\n\necho \"\u2705 Updated attestation (supersedes original):\"\nenvelope format \"$S_SIGNED_ATTESTATION\" | head -12\n\n| \u2705 Updated attestation (supersedes original):\n| {\n|     \"Contributed mass spec visualization and data pipeline code to galaxyproject/galaxy (PRs #12847, #14201, #15892, 2024-2026)\" [\n|         'isA': 'attestation'\n|         \"supersedes\": Digest(40993e58)\n|         'date': \"2026-02-18T13:14-10:00\"\n|         'source': XID(5f1c3d9e)\n|         'target': XID(5f1c3d9e)\n|         'verifiableAt': URI(https://github.com/galaxyproject/galaxy/pulls?q=author:BRadvoc8)\n|     ]\n| } [\n|     'signed': Signature(Ed25519)\n| ]\n</code></pre> <p>\ud83d\udcd6 What is a Superseding Attestation?: A superseding attestation is a new attestation with a <code>supersedes</code> assertion that points to a previous attestation's digest. The original remains valid, but the newer attestation reflects the current state.</p>"},{"location":"02_1_Creating_Self_Attestations/#step-15-retract-an-attestation","title":"Step 15: Retract an Attestation","text":"<p>If an attestation instead needed to be retracted, our best practive suggests a pattern as follows:</p> <pre><code>RETRACTION=$(envelope subject type string \"RETRACTED: [original claim text]\")\nRETRACTION=$(envelope assertion add pred-obj known isA string \"retraction\" \"$RETRACTION\")\nRETRACTION=$(envelope assertion add pred-obj string \"retracts\" digest \"$ORIGINAL_DIGEST\" \"$RETRACTION\")\nRETRACTION=$(envelope assertion add pred-obj string \"reason\" string \"Claim was overstated\" \"$RETRACTION\")\nRETRACTION=$(envelope subject type wrapped \"$RETRACTION\")\nRETRACTION=$(envelope sign --signer \"$ATTESTATION_PRVKEYS\" \"$RETRACTION\")\n</code></pre> <p>The result would look like this:</p> <pre><code>envelope format $RETRACTION\n\n| {\n|     \"RETRACTED: [original claim text]\" [\n|         'isA': \"retraction\"\n|         \"reason\": \"Claim was overstated\"\n|         \"retracts\": Digest(40993e58)\n|     ]\n| } [\n|     'signed': Signature(Ed25519)\n| ]\n</code></pre> <p>Retractions are serious: they indicate an error in judgment. Use them sparingly. Most updates are supersessions (extending or refining), not retractions (correcting errors). Amira definteily won't be retracting anything at this point!</p> <p>\ud83d\udcd6 What is a Retracting Attestation?: A superseding attestation is a Gordian Envelope that references a previous attestation and states both that it's been retracted and why.</p>"},{"location":"02_1_Creating_Self_Attestations/#summary-the-world-of-attestations","title":"Summary: The World of Attestations","text":"<p>This tutorial talked a lot about claims, or attestations, including revealing many sorts:</p> <ul> <li>Detached Attestation. Creating an attestation separted from your XID, but linked by a signature.</li> <li>Embedded Attestation. Incorporating an attestation into a XID.</li> <li>Endorsement. Making a claim about someone else.</li> <li>Fair Witness Attestation. Reporting without interpretation or known bias.</li> <li>Retracting Attestation. Invalidating a prior attestation</li> <li>Self Attestation. Making a claim about yourself.</li> <li>Superseding Attestation. Updating a prior attestation.</li> </ul> <p>This tutorial focused on a detached fair-witness self attestation. Embedded attestations and endorsements will follow starting in Tutorial 06.</p> <p>Crucially, this tutorial also showed how to create a validated attestation: the Galaxy Project attestation isn't just a claim, it's a claim with a URL where anyone can check the actual code. But could it have been stronger? That's also a topic for the future.</p>"},{"location":"02_1_Creating_Self_Attestations/#exercises","title":"Exercises","text":"<p>Building exercises (Amira's perspective):</p> <ul> <li>Create a fair witness attestation for one of your own verifiable contributions (GitHub PR, package, blog post).</li> <li>Register a new dedicated attestation key in your XID.</li> </ul> <p>Verification exercises (Ben's perspective):</p> <ul> <li>Given an attestation envelope, extract the <code>verifiableAt</code> URL and check if the evidence exists.</li> <li>Verify the signature using the attestation key from the XID.</li> </ul> <p>Analysis exercises:</p> <ul> <li>Compare a fair witness claim to a vague claim about the same skill: what makes the fair witness version stronger?</li> <li>Identify 2-3 public contributions you could attest to with verifiable evidence.</li> </ul>"},{"location":"02_1_Creating_Self_Attestations/#whats-next","title":"What's Next","text":"<p>BRadvoc8 is now an identity with an initial claim about skills, but that's opened a bit of a Pandora's box. The next two tutorials will seek to close by showing how to elide sensitive claims in \u00a72.2: Managing Sensitive Claims with Elision and \u00a72.3: Managing Sensitive Claims with Encryption.</p>"},{"location":"02_1_Creating_Self_Attestations/#example-script","title":"Example Script","text":"<p>A complete working script implementing this tutorial is available at <code>../tests/03-creating-self-attestations.sh</code>.</p>"},{"location":"02_1_Creating_Self_Attestations/#appendix-i-key-terminology","title":"Appendix I: Key Terminology","text":"<p>Attestation Key: A dedicated signing key for creating detached attestations, registered in your XID. Verified against the XID key list, not an external service.</p> <p>Fair Witness Methodology: Making only factual, specific, verifiable claims rather than opinions or vague assertions.</p> <p>Also see the various attestation definitions in the Summary.</p>"},{"location":"02_2_Managing_Claims_Elision/","title":"2.2: Managing Sensitive Claims with Elision","text":"<p>This sections describes how to handle credentials that are too risky to publish publicly using commitment patterns and selective disclosure.</p> <p>\ud83e\udde0 Related Concepts. After completing this tutorial, explore Progressive Trust and Self-Attestation to deepen your understanding.</p>"},{"location":"02_2_Managing_Claims_Elision/#objectives-for-this-section","title":"Objectives for this Section","text":"<p>After working through this section, a developer will be able to:</p> <ul> <li>Make a commitment.</li> <li>Verify a commitment against a revealed claim.</li> </ul> <p>Supporting objectives include the ability to:</p> <ul> <li>Understand how correlation risk compounds with each public claim.</li> <li>Differentiate between three approaches for handling sensitive information.</li> <li>Undestand how inclusion proofs allow you to commit now and reveal later.</li> </ul>"},{"location":"02_2_Managing_Claims_Elision/#amiras-story-every-claim-narrows-the-field","title":"Amira's Story: Every Claim Narrows the Field","text":"<p>Amira did cryptographic audit work for a fintech startup in 2023-2024. She reviewed authentication implementations, found vulnerabilities, and helped to fix them. It's valuable experience that would strengthen her credibility for security work. But \"crypto auditor\" is a rare skill. How many people worldwide have done professional cryptographic audits? Maybe a few thousand. Combine that with other public claims, which might include that she's a Galaxy Project contributor, is privacy-focused, and speaks Portuguese, and the intersection might describe only a handful of people.</p> <p>This is correlation risk. Each claim by itself might be safe. Combined, they create a fingerprint.</p> <p>\ud83d\udcd6 What is a Correlation Risk? Public information can be combined to narrow an anonymity set until it identifies a specific person. Each additional claim shrinks the pool of people who could match. This creates correlation risk.</p>"},{"location":"02_2_Managing_Claims_Elision/#how-claims-compound","title":"How Claims Compound","text":"<p>Watch how Amira's anonymity set shrinks:</p> Claims Combined Approximate Population \"Security professional\" Hundreds of thousands + \"8 years experience\" Tens of thousands + \"Privacy focus\" Thousands + \"Crypto audit experience\" Hundreds + \"Galaxy Project contributor\" Maybe dozens + \"Based in South America\" Single digits <p>That last combination might describe three people in the world. If an adversary knows those facts and sees BRadvoc8's public profile, correlation becomes trivial.</p> <p>\u26a0\ufe0f Consider the Correlation Risks Before Making Claims. Ask \"How many people worldwide could truthfully make this exact statement?\" If the answer is under 100, combine it with your other public claims and ask again. If the combined answer approaches single digits, that claim needs special handling.</p>"},{"location":"02_2_Managing_Claims_Elision/#the-possibilities-of-protecting-sensitive-data","title":"The Possibilities of Protecting Sensitive Data","text":"<p>Amira has three options for handling the correlation risk of her crypto audit experience.</p> <ul> <li>Option 1: Omit Entirely. Don't mention it at all. If Amira never needs to prove this experience, keeping it private is the safest choice. There's zero correlation risk from information that isn't published. The downside is that she loses the reputation benefit. If crypto audit experience would help her get accepted onto a security project, omitting it means she can't use it.</li> <li>Option 2: Commit Elided. Create the attestation and sign it, but publish only an opaque commitment (the digest). The commitment proves that Amira had some claim at a specific time, without revealing what the claim says. Later, she can reveal the full attestation to specific people who can verify that it matches the public commitment. This is the \"prove I had it all along\" pattern. It's useful when you might need to demonstrate timing without revealing content and also tends to give weight to a claim because it didn't come out of nowhere. This is what we'll cover in this Tutorial.</li> <li>Option 3: Encrypt for Recipient. Create the attestation and encrypt it for a specific person's public key. Only that person can read it. No public trace at all. This is covered in Tutorial \u00a72.3. It's the right choice when a specific trusted person needs to see the claim now, and you don't need to prove timing to anyone else.</li> </ul> Situation Approach Never need to prove this Omit entirely Might need to prove later Commit elided Specific person needs it now Encrypt for them <p>Amira decides her crypto audit experience fits the middle category. She might need to prove this capability to future collaborators, but she doesn't want to publish it broadly. She'll commit an elided version publicly and reveal the full attestation selectively.</p> <p>\ud83e\udde0 Learn more: These three approaches are part of the broader concept of Selective Disclosure, which is the ability to reveal different information to different parties from the same underlying data structure.</p>"},{"location":"02_2_Managing_Claims_Elision/#part-i-creating-a-commitment","title":"Part I: Creating a Commitment","text":""},{"location":"02_2_Managing_Claims_Elision/#step-0-verify-dependencies-reload-xid","title":"Step 0: Verify Dependencies &amp; Reload XID","text":"<p>As usual, check your <code>envelope-cli</code> version:</p> <pre><code>envelope --version\n\n\u2502 bc-envelope-cli 0.34.1\n</code></pre> <p>Then, reload your XID, primarily to have easy access to your XID ID:</p> <pre><code>XID=$(cat envelopes/BRadvoc8-xid-private-02.envelope)\nXID_ID=$(envelope xid id $XID)\n</code></pre> <p>You should then reload your Attestation keys from the last tutorial:</p> <pre><code>ATTESTATION_PRVKEYS=$(cat envelopes/attestation-private-03.ur)\nATTESTATION_PUBKEYS=$(cat envelopes/attestation-public-03.ur)\n</code></pre> <p>If you instead need to create new ones, see \u00a72.2 for how to do so, then register your keys in your XID.</p>"},{"location":"02_2_Managing_Claims_Elision/#step-1-create-the-sensitive-attestation","title":"Step 1: Create the Sensitive Attestation","text":"<p>You should create Amira's crypto audit attestation with fair witness precision:</p> <pre><code>AUDIT_CLAIM=$(envelope subject type string \\\n  \"Audited cryptographic implementations for authentication systems (2023-2024)\")\nAUDIT_CLAIM=$(envelope assertion add pred-obj known isA known 'attestation' \"$AUDIT_CLAIM\")\nAUDIT_CLAIM=$(envelope assertion add pred-obj known source ur $XID_ID \"$AUDIT_CLAIM\")\nAUDIT_CLAIM=$(envelope assertion add pred-obj known target ur $XID_ID \"$AUDIT_CLAIM\")\nAUDIT_CLAIM=$(envelope assertion add pred-obj known 'date' string `date -Iminutes` \"$AUDIT_CLAIM\")\nAUDIT_CLAIM=$(envelope assertion add pred-obj string \"skillCategory\" string \"Security\" \"$AUDIT_CLAIM\")\n\nenvelope format \"$AUDIT_CLAIM\"\n\n| \"Audited cryptographic implementations for authentication systems (2023-2024)\" [\n|     'isA': 'attestation'\n|     \"skillCategory\": \"Security\"\n|     'date': \"2026-02-18T15:08-10:00\"\n|     'source': XID(5f1c3d9e)\n|     'target': XID(5f1c3d9e)\n| ]\n</code></pre> <p>Notice that you don't include the company name that Amira worked for or specific details that would make correlation easier. The claim is specific enough to be meaningful but not so detailed that it uniquely identifies her.</p>"},{"location":"02_2_Managing_Claims_Elision/#step-2-sign-the-full-attestation","title":"Step 2: Sign the Full Attestation","text":"<p>Next, you follow the normal procedure to wrap and sign the attestation:</p> <pre><code>AUDIT_WRAPPED=$(envelope subject type wrapped \"$AUDIT_CLAIM\")\nAUDIT_SIGNED=$(envelope sign --signer \"$ATTESTATION_PRVKEYS\" \"$AUDIT_WRAPPED\")\n\necho \"\u2705 Full attestation created and signed\"\nenvelope format \"$AUDIT_SIGNED\"\n\n| \u2705 Full attestation created and signed\n| {\n|     \"Audited cryptographic implementations for authentication systems (2023-2024)\" [\n|         'isA': 'attestation'\n|         \"skillCategory\": \"Security\"\n|         'date': \"2026-02-18T15:08-10:00\"\n|         'source': XID(5f1c3d9e)\n|         'target': XID(5f1c3d9e)\n|     ]\n| } [\n|     'signed': Signature(Ed25519)\n| ]\n</code></pre> <p>This is the full attestation that Amira will keep secure and private. But she wants to publicly share the fact that she made this claim, while not revealing exactly what it is; that requires the creation of an elided view.</p>"},{"location":"02_2_Managing_Claims_Elision/#step-3-create-the-elided-commitment","title":"Step 3: Create the Elided Commitment","text":"<p>You can now create a view of the attestation with the content removed but the cryptographic structure preserved:</p> <pre><code>AUDIT_DIGEST=$(envelope digest \"$AUDIT_SIGNED\")\nAUDIT_ELIDED=$(envelope elide removing \"$AUDIT_DIGEST\" \"$AUDIT_SIGNED\")\n\necho \"\u2705 Elided commitment created\"\necho \"Digest: $AUDIT_DIGEST\"\nenvelope format \"$AUDIT_ELIDED\"\n\n\u2502 \u2705 Elided commitment created\n\u2502 Digest: ur:digest/hdcxlgahgagmckdrveclotpeaerfynndksjpsphhoywtfeotlgdtwkwdwpmhgsylndlyrndscaah\n\u2502 ELIDED\n</code></pre> <p>The elided version shows nothing, just the word <code>ELIDED</code>. But here's the key property: the hash (digest) of the elided envelope will be identical to the hash of the original envelope, offering proof that their content is identical, even though it can not longer be seen in the elided envelope.</p> <p>This commitment could be published in a variety of ways. Amira might have a set of self-attestations available on her GitHub, some of which are elided and some of which are not. Or, she might maintain a public commitment list. This is typically a list of digests in a public profile with category hints (e.g., \"Security\", \"Privacy Engineering\"). This tells collaborators that she has additional credentials without revealing what they are.</p> <p>\ud83d\udcd6 What is a Commitment? A commitment is literally a promise. Cryptographically, a commitment is a promise that you have recorded a certain value. All you reveal is a hash of that value, which is the cryptographic commitment. Since (probabalistically) each recorded value only leads to one hash, when you reveal the original value and it hashes correctly, your commitment has been fulfilled.</p>"},{"location":"02_2_Managing_Claims_Elision/#part-ii-revealing-a-commitment","title":"Part II: Revealing a Commitment","text":"<p>Amira set up her audit commitment when she created her BRadvoc8 identity, so that she could work with Ben. But the whole point of commitments is that they sit around, gaining trust as they do, and tend to be revealed later. That's the case here.  Six months later, Amira has approached DevReviewer for a security collaboration.</p>"},{"location":"02_2_Managing_Claims_Elision/#step-4-highlight-the-commitment","title":"Step 4: Highlight the Commitment","text":"<p>DevReviewer has seen Amir'as public attestation (about the Galaxy Project) but want to know about her security audit experience. Amira mentions that she has relevant experience but couldn't share details publicly. She points to the commitment.</p> <p>DevReviewer looks at the commitment, which is stored on GitHub, and uses its (more trustworthy) datestamping to verify it was commited to GitHub about six months ago, and it's one of just a few public commitments of that sort.</p>"},{"location":"02_2_Managing_Claims_Elision/#step-5-reveal-the-unelided-claim","title":"Step 5: Reveal the Unelided Claim","text":"<p>Amira next sends DevReviewer the full attestation (<code>$AUDIT_SIGNED</code>) via a secure message system. DevReviewer now has both versions.</p>"},{"location":"02_2_Managing_Claims_Elision/#part-iii-verifying-the-commitment","title":"Part III: Verifying the Commitment","text":"<p>We now switch to DevReviewer's point of view. Their verification of the full attestation will come in two parts: checking that this is the same document as the commitment (which is very similar to the process of checking an inclusion proof) and verifying the signature.</p> <p>\ud83d\udcd6 What is an Inclusion Proof? An inclusion proof typically reveals that a piece of data is part of a larger data set without revealing the entirety of the larger data set. For example, you could a claim was in a partially elided Gordian Envelope just by knowing a hash of the claim that was still visible in the envelope. Verifying a commitment of this sort isn't quite the same thing since here we're checking that a piece of data matches another piece of data that isn't entirely revealed. But the theory and the procedure are largely the same.</p>"},{"location":"02_2_Managing_Claims_Elision/#step-6-test-the-commitment","title":"Step 6: Test the Commitment","text":"<p>DevReviewer computes the digest of what they received:</p> <pre><code>ELIDED_DIGEST=$(envelope digest \"$AUDIT_ELIDED\") # Downloaded from GitHub\nRECEIVED_DIGEST=$(envelope digest \"$AUDIT_SIGNED\") # Received from Amira\n</code></pre> <p>They then compare these two digests, the commited digest (downloaded from GitHub) and the digest on the fully visible claim (received from Amira).</p> <pre><code>echo \"Commitment digest: $ELIDED_DIGEST\"\necho \"Received digest:   $RECEIVED_DIGEST\"\n\nif [ \"$RECEIVED_DIGEST\" = \"$ELIDED_DIGEST\" ]; then\n    echo \"\u2705 Inclusion proof valid: this matches the public commitment\"\nelse\n    echo \"\u274c WARNING: Does not match commitment\"\nfi\n\n\u2502 Commitment digest: ur:digest/hdcxlgahgagmckdrveclotpeaerfynndksjpsphhoywtfeotlgdtwkwdwpmhgsylndlyrndscaah\n\u2502 Received digest:   ur:digest/hdcxlgahgagmckdrveclotpeaerfynndksjpsphhoywtfeotlgdtwkwdwpmhgsylndlyrndscaah\n\u2502 \u2705 Inclusion proof valid: this matches the public commitment\n\n</code></pre> <p>The digests match. This proves the full attestation Amira revealed is the same document she committed to earlier, not something she fabricated after the fact.</p> <p>\ud83d\udcd6 Why Is It Important that Amira Committed in Advance? Amira committing and publishing her elided commitment about her security audit work literally shows commitment. Progressive trust is all about establishing and improving levels of trust, and this is a strong signal that Amira can be trusted on this claim (which is otherwise not verifiable). She made the statement some time ago. It's been publicly available on the web for some time, something that might be verifiable by GitHub timestamps or archive.org storage. It's also presumably a part of a relatively small set of claims (or at least a relatively small set of hidden claims). That means that Amira isn't just pulling the claim that she can do security audits out of a hat. It's one of a small number of things she said some time ago, increasing its credibility despite the lack of verification. </p>"},{"location":"02_2_Managing_Claims_Elision/#step-7-verify-the-signature","title":"Step 7: Verify the Signature","text":"<p>Finally, DevReviewer uses Amira's public attestation key, previously extracted from her public XID, to verify that the attesetation was indeed made by Amira. (See \u00a72.1 for a more complex methodology to check a signature against every public key in a XID.)</p> <pre><code>envelope verify -s --verifier \"$ATTESTATION_PUBKEYS\" \"$AUDIT_SIGNED\"\n\n\u2502 (no response means signature is valid.)\n</code></pre> <p>The signature is valid.</p>"},{"location":"02_2_Managing_Claims_Elision/#step-8-assess-your-level-of-trust","title":"Step 8: Assess Your Level of Trust","text":"<p>Combining the valid signature with the verified commitment, DevReviewer has three pieces of information:</p> What DevReviewer Can Verify What Remains Unproven \u2705 Claim matches a public commitment \u2753 Claim is actually true \u2705 Claim was published at a previous date \u2753 What other hidden claims say \u2705 Claim was not modified \u2753 Whether claim varies a different hidden claim \u2705 BRadvoc8 signed the claim \u2753 Who BRadvoc8 is <p>DevReviewer can now read the claim and factor it into their trust decision.</p>"},{"location":"02_2_Managing_Claims_Elision/#a-review-of-envelope-elision","title":"A Review of Envelope Elision","text":"<p>There's an important limitation to understand for elision. A fully <code>ELIDED</code> envelope has no content, no metadata, and no signature visible.</p> <pre><code>envelope format \"$AUDIT_ELIDED\"\n\n\u2502 ELIDED\n</code></pre> <p>That means that the envelope's signature can't be verified while it's elided:</p> <pre><code>envelope verify -s --verifier \"$ATTESTATION_PUBKEYS\" \"$AUDIT_ELIDED\"\n\n\u2502 Error: could not verify a signature\n</code></pre> <p>The elided version is just a digest placeholder: it proves something with its digest, but you can't verify its authenticity without the full version. This is by design. The commitment pattern separates timing from content: in the commit phase, you publish the elided version to prove when you made the claim; in the reveal phase, you share the full version with specific people to prove what you claimed; then the recipient verifies the revealed version matches the public commitment.</p>"},{"location":"02_2_Managing_Claims_Elision/#part-iv-managing-the-commitment-lifecycle","title":"Part IV: Managing the Commitment Lifecycle","text":"<p>This doesn't have to be the end of the life cycle of a commitment.</p>"},{"location":"02_2_Managing_Claims_Elision/#step-9-supersede-a-commitment","title":"Step 9: Supersede a Commitment","text":"<p>If Amira's skills evolve, of if she joins other projects, she can create new commitments, just as she managed the lifecycle of her visible attestations. Old commitments remain valid but can be retired.</p>"},{"location":"02_2_Managing_Claims_Elision/#summary-from-correlation-to-elision","title":"Summary: From Correlation to Elision","text":"<p>This tutorial introduced the problem of correlation risk: how claims compound to narrow anonymity sets. The three disclosure approaches (omit, commit, encrypt) give you options for different situations. Commit means creating a sensitive attestation and committed to it publicly without revealing the content. This inclusion proof pattern lets Amira prove she had this credential all along when she chooses to reveal it: she can't be accused of fabricating it after the fact.</p>"},{"location":"02_2_Managing_Claims_Elision/#exercises","title":"Exercises","text":"<ol> <li>Identify a skill you have that would be risky to publish publicly. What makes it identifying?</li> <li>Create an elided commitment for a hypothetical sensitive attestation.</li> <li>Walk through the verification steps as if you were DevReviewer receiving a revealed attestation</li> </ol>"},{"location":"02_2_Managing_Claims_Elision/#whats-next","title":"What's Next","text":"<p>The commit-reveal pattern works for proving timing and existence. But what about claims so sensitive that even a hint of their existence is risky? That's the topic \u00a72.3: Managing Sensitive Claims with Encryption.</p>"},{"location":"02_2_Managing_Claims_Elision/#appendix-i-key-terminology","title":"Appendix I: Key Terminology","text":"<p>Commitment: A digest that commits to certain content that is being elided or otherwise withheld.</p> <p>Correlation Risk: The potential for combining public information to identify a pseudonym. Claims compound: each one narrows the anonymity set.</p> <p>Elided Envelope: An envelope with content removed but cryptographic identity (digest) preserved. Proves existence without revealing content.</p> <p>Inclusion Proof: A demonstration that a revealed document is found in a larger document that has not been entirely revealed.</p>"}]}